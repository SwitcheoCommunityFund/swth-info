"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.accountFromMnemonic = exports.newAccount = exports.getPrivKeyFromMnemonic = exports.WalletClient = void 0;
var bip32 = __importStar(require("bip32"));
var bip39 = __importStar(require("bip39"));
var node_fetch_1 = __importDefault(require("node-fetch"));
var bignumber_js_1 = require("bignumber.js");
var eth_dagger_1 = __importDefault(require("@maticnetwork/eth-dagger"));
var ethers_1 = require("ethers");
var config_1 = require("../config");
var containers_1 = require("../containers");
var encoder_1 = require("../utils/encoder");
var wallet_1 = require("../utils/wallet");
var hdwallet_1 = require("../utils/hdwallet");
var balanceReader_json_1 = __importDefault(require("../eth/abis/balanceReader.json"));
var lockProxy_json_1 = __importDefault(require("../eth/abis/lockProxy.json"));
var constants_1 = require("../constants");
var neon_js_1 = __importStar(require("@cityofzion/neon-js"));
var strip_hex_prefix_1 = __importDefault(require("strip-hex-prefix"));
var neon_core_1 = require("@cityofzion/neon-core");
var lodash_1 = require("lodash");
var WalletClient = /** @class */ (function () {
    function WalletClient(params) {
        var _this = this;
        var mnemonic = params.mnemonic, pubKeyBech32 = params.pubKeyBech32, pubKey = params.pubKey, accountNumber = params.accountNumber, network = params.network, _a = params.broadcastQueueIntervalTime, broadcastQueueIntervalTime = _a === void 0 ? 100 : _a, _b = params.useSequenceCounter, useSequenceCounter = _b === void 0 ? true : _b, privateKey = params.privateKey, signerType = params.signerType, ledger = params.ledger, _c = params.gas, gas = _c === void 0 ? config_1.CONFIG.DEFAULT_GAS : _c, onRequestSign = params.onRequestSign, onSignComplete = params.onSignComplete, fees = params.fees;
        if (!mnemonic && signerType === 'mnemonic') {
            throw new Error('Signer Type is mnemonic but mnemonic is not passed in');
        }
        if (!privateKey && signerType === 'privateKey') {
            throw new Error('Signer Type is privateKey but privateKey is not passed in');
        }
        var address;
        if (mnemonic) {
            var privateKey_1 = getPrivKeyFromMnemonic(mnemonic);
            var privKey = new wallet_1.PrivKeySecp256k1(Buffer.from(privateKey_1, 'hex'));
            this.mnemonic = mnemonic;
            this.hdWallet = hdwallet_1.HDWallet.getWallet(mnemonic);
            this.privKey = privKey;
            this.pubKeySecp256k1 = this.privKey.toPubKey();
            address = this.pubKeySecp256k1.toAddress();
            this.pubKeyBase64 = this.pubKeySecp256k1.pubKey.toString('base64');
        }
        else if (privateKey) {
            this.privKey = new wallet_1.PrivKeySecp256k1(Buffer.from(privateKey, 'hex'));
            this.pubKeySecp256k1 = this.privKey.toPubKey();
            address = this.pubKeySecp256k1.toAddress();
            this.pubKeyBase64 = this.pubKeySecp256k1.pubKey.toString('base64');
        }
        else if (signerType === 'nosign') {
            address = wallet_1.Address.fromBech32(config_1.getBech32Prefix(network, 'main'), pubKeyBech32);
        }
        else {
            this.pubKeySecp256k1 = new wallet_1.PubKeySecp256k1(Buffer.from(pubKey));
            this.pubKeyBase64 = this.pubKeySecp256k1.pubKey.toString('base64');
            address = wallet_1.Address.fromBech32(config_1.getBech32Prefix(network, 'main'), pubKeyBech32);
        }
        this.fees = fees;
        this.address = address.toBytes();
        this.addressHex = strip_hex_prefix_1.default(ethers_1.ethers.utils.hexlify(this.address));
        this.pubKeyBech32 = address.toBech32(config_1.getBech32Prefix(network, 'main'));
        this.validatorBech32 = address.toBech32(config_1.getBech32Prefix(network, 'validator'));
        this.consensusBech32 = address.toBech32(config_1.getBech32Prefix(network, 'consensus'));
        this.signerType = signerType;
        this.gas = gas;
        this.accountNumber = accountNumber;
        this.network = network;
        this.depositAddresses = {};
        this.ledger = ledger;
        this.onRequestSign = onRequestSign;
        this.onSignComplete = onSignComplete;
        this.feeMultiplier = ethers_1.ethers.BigNumber.from(2);
        this.useSequenceCounter = useSequenceCounter;
        this.broadcastQueueIntervalTime = broadcastQueueIntervalTime;
        this.broadcastQueue = [];
        this.broadcastResults = {};
        this.broadcastQueueIntervalId = setInterval(function () {
            _this.processBroadcastQueue();
        }, this.broadcastQueueIntervalTime);
    }
    WalletClient.connectMnemonic = function (mnemonic, net) {
        return __awaiter(this, void 0, void 0, function () {
            var network;
            return __generator(this, function (_a) {
                network = config_1.getNetwork(net);
                return [2 /*return*/, new WalletClient({
                        mnemonic: mnemonic,
                        network: network,
                        signerType: 'mnemonic',
                    })];
            });
        });
    };
    WalletClient.connectPrivateKey = function (privateKey, net) {
        return __awaiter(this, void 0, void 0, function () {
            var network;
            return __generator(this, function (_a) {
                network = config_1.getNetwork(net);
                return [2 /*return*/, new WalletClient({
                        privateKey: privateKey,
                        network: network,
                        signerType: 'privateKey',
                    })];
            });
        });
    };
    WalletClient.connectLedger = function (cosmosLedger, net, onRequestSign, onSignComplete) {
        if (net === void 0) { net = 'TESTNET'; }
        return __awaiter(this, void 0, void 0, function () {
            var network, pubKeyBech32, pubKey;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        network = config_1.getNetwork(net);
                        return [4 /*yield*/, cosmosLedger.getCosmosAddress()];
                    case 1:
                        pubKeyBech32 = _a.sent();
                        return [4 /*yield*/, cosmosLedger.getPubKey()];
                    case 2:
                        pubKey = _a.sent();
                        return [2 /*return*/, new WalletClient({
                                ledger: cosmosLedger,
                                network: network,
                                pubKey: pubKey,
                                pubKeyBech32: pubKeyBech32,
                                signerType: 'ledger',
                                onRequestSign: onRequestSign,
                                onSignComplete: onSignComplete,
                            })];
                }
            });
        });
    };
    // for debug view
    WalletClient.connectPublicKey = function (pubKeyBech32, net) {
        return __awaiter(this, void 0, void 0, function () {
            var network;
            return __generator(this, function (_a) {
                network = config_1.getNetwork(net);
                return [2 /*return*/, new WalletClient({
                        network: network,
                        pubKeyBech32: pubKeyBech32,
                        signerType: 'nosign',
                    })];
            });
        });
    };
    WalletClient.prototype.disconnect = function () {
        clearInterval(this.broadcastQueueIntervalId);
        clearInterval(this.neoDepositsIntervalId);
    };
    WalletClient.prototype.sign = function (message) {
        var privKey = this.privKey;
        var data = privKey.sign(message);
        var signatureBase64 = Buffer.from(data.signature).toString('base64');
        return {
            pub_key: {
                type: 'tendermint/PubKeySecp256k1',
                value: this.pubKeyBase64,
            },
            signature: signatureBase64,
        };
    };
    WalletClient.prototype.initialize = function (params) {
        if (params.fees) {
            this.fees = params.fees;
        }
        if (params.accountNumber) {
            this.accountNumber = params.accountNumber;
        }
    };
    WalletClient.prototype.broadcast = function (body) {
        return node_fetch_1.default(this.network.REST_URL + "/txs", { method: 'POST', body: JSON.stringify(body) })
            .then(function (res) { return res.json(); }); // expecting a json response
    };
    WalletClient.prototype.getAccount = function () {
        return node_fetch_1.default(this.network.REST_URL + "/get_account?account=" + this.pubKeyBech32)
            .then(function (res) { return res.json(); }); // expecting a json response
    };
    WalletClient.prototype.getWalletBalance = function () {
        return node_fetch_1.default(this.network.REST_URL + "/get_balance?account=" + this.pubKeyBech32)
            .then(function (res) { return res.json(); }); // expecting a json response
    };
    WalletClient.prototype.getTransfers = function () {
        return node_fetch_1.default(this.network.REST_URL + "/get_external_transfers?account=" + this.pubKeyBech32)
            .then(function (res) { return res.json(); }); // expecting a json response
    };
    WalletClient.prototype.watchDepositAddresses = function (whitelistDenoms) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this.watchNeoDepositAddress(whitelistDenoms);
                this.watchEthDepositAddress(whitelistDenoms);
                return [2 /*return*/];
            });
        });
    };
    WalletClient.prototype.watchNeoDepositAddress = function (whitelistDenoms) {
        return __awaiter(this, void 0, void 0, function () {
            var address;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getDepositAddress(constants_1.Blockchain.Neo)];
                    case 1:
                        address = _a.sent();
                        return [4 /*yield*/, this.sendNeoDeposits(address, whitelistDenoms)
                            // check every 15 seconds
                        ];
                    case 2:
                        _a.sent();
                        // check every 15 seconds
                        this.neoDepositsIntervalId = setInterval(function () {
                            _this.sendNeoDeposits(address, whitelistDenoms);
                        }, 15 * 1000);
                        return [2 /*return*/];
                }
            });
        });
    };
    WalletClient.prototype.sendNeoDeposits = function (address, whitelistDenoms) {
        return __awaiter(this, void 0, void 0, function () {
            var url, tokens, i, token, feeAmount;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getNeoRpcUrl()];
                    case 1:
                        url = _a.sent();
                        return [4 /*yield*/, this.getNeoExternalBalances(address, url, whitelistDenoms)];
                    case 2:
                        tokens = _a.sent();
                        i = 0;
                        _a.label = 3;
                    case 3:
                        if (!(i < tokens.length)) return [3 /*break*/, 6];
                        token = tokens[i];
                        if (!(token.external_balance !== undefined && token.external_balance !== '0')) return [3 /*break*/, 5];
                        feeAmount = ethers_1.ethers.BigNumber.from('100000000');
                        return [4 /*yield*/, this.sendNeoDeposit(token, feeAmount)];
                    case 4:
                        _a.sent();
                        _a.label = 5;
                    case 5:
                        i++;
                        return [3 /*break*/, 3];
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    WalletClient.prototype.getTargetProxyHash = function (token) {
        var prefix = config_1.getBech32Prefix(this.network, 'main');
        var address = wallet_1.Address.fromBech32(prefix, token.originator);
        var addressBytes = address.toBytes();
        var addressHex = strip_hex_prefix_1.default(ethers_1.ethers.utils.hexlify(addressBytes));
        return addressHex;
    };
    WalletClient.prototype.getFeeInfo = function (denom) {
        return __awaiter(this, void 0, void 0, function () {
            var url, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = this.network.FEE_URL + '/fees?denom=' + denom;
                        return [4 /*yield*/, node_fetch_1.default(url).then(function (res) { return res.json(); })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result];
                }
            });
        });
    };
    WalletClient.prototype.sendNeoDeposit = function (token, feeAmountInput, _privateKey) {
        if (_privateKey === void 0) { _privateKey = null; }
        return __awaiter(this, void 0, void 0, function () {
            var privateKey, account, scriptHash, fromAssetHash, fromAddress, targetProxyHash, toAssetHash, toAddress, amount, feeAmount, feeAddress, nonce, sb, rpcUrl, apiProvider;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        privateKey = !!_privateKey ? _privateKey : this.hdWallet[constants_1.Blockchain.Neo];
                        account = neon_js_1.default.create.account(privateKey);
                        scriptHash = neon_js_1.u.reverseHex(token.lock_proxy_hash);
                        fromAssetHash = token.asset_id;
                        fromAddress = neon_js_1.u.reverseHex(account.scriptHash);
                        targetProxyHash = this.getTargetProxyHash(token);
                        toAssetHash = neon_js_1.u.str2hexstring(token.denom);
                        toAddress = this.addressHex;
                        amount = ethers_1.ethers.BigNumber.from(token.external_balance);
                        feeAmount = ethers_1.ethers.BigNumber.from(feeAmountInput !== null && feeAmountInput !== void 0 ? feeAmountInput : '100000000');
                        feeAddress = this.network.FEE_ADDRESS;
                        nonce = Math.floor(Math.random() * 1000000);
                        if (amount.lt(feeAmount)) {
                            return [2 /*return*/, false];
                        }
                        sb = neon_js_1.default.create.scriptBuilder();
                        sb.emitAppCall(scriptHash, 'lock', [
                            fromAssetHash,
                            fromAddress,
                            targetProxyHash,
                            toAssetHash,
                            toAddress,
                            amount.toNumber(),
                            feeAmount.toNumber(),
                            feeAddress,
                            nonce
                        ]);
                        return [4 /*yield*/, this.getNeoRpcUrl()];
                    case 1:
                        rpcUrl = _a.sent();
                        apiProvider = this.network.NAME === 'mainnet' ?
                            new neon_js_1.api.neonDB.instance('https://api.switcheo.network')
                            : new neon_js_1.api.neoCli.instance(rpcUrl);
                        return [2 /*return*/, neon_js_1.default.doInvoke({
                                api: apiProvider,
                                url: rpcUrl,
                                account: account,
                                script: sb.str,
                                gas: 0,
                                fees: 0
                            })];
                }
            });
        });
    };
    WalletClient.prototype.watchEthDepositAddress = function (whitelistDenoms) {
        return __awaiter(this, void 0, void 0, function () {
            var address, dagger, transferKey;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getDepositAddress(constants_1.Blockchain.Ethereum)
                        // do an initial check
                    ];
                    case 1:
                        address = _a.sent();
                        // do an initial check
                        return [4 /*yield*/, this.sendEthDeposits(address, whitelistDenoms)];
                    case 2:
                        // do an initial check
                        _a.sent();
                        dagger = new eth_dagger_1.default(this.network.ETH_WS_URL);
                        // watch for Ethereum transfers
                        dagger.on("latest:addr/" + address + "/tx/in", function () {
                            _this.sendEthDeposits(address, whitelistDenoms);
                        });
                        transferKey = '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef';
                        dagger.on("latest:log/+/filter/" + transferKey + "/+/" + address + "/#", function () {
                            _this.sendEthDeposits(address, whitelistDenoms);
                        });
                        return [2 /*return*/];
                }
            });
        });
    };
    WalletClient.prototype.sendEthDeposits = function (address, whitelistDenoms) {
        return __awaiter(this, void 0, void 0, function () {
            var tokens, _loop_1, i;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getEthExternalBalances(address, whitelistDenoms)];
                    case 1:
                        tokens = _a.sent();
                        _loop_1 = function (i) {
                            var token = tokens[i];
                            var balance = ethers_1.ethers.BigNumber.from(token.external_balance);
                            if (!balance.isZero()) {
                                // send the deposit in 30 seconds to avoid problems with block re-orgs
                                // if the deposit is sent too early, and there is a block re-org then the
                                // ethpayer service might check and see that there is no token balance and
                                // it would ignore the request
                                setTimeout(function () { return __awaiter(_this, void 0, void 0, function () {
                                    var e_1;
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0:
                                                _a.trys.push([0, 2, , 3]);
                                                return [4 /*yield*/, this.sendEthDeposit(token, address)];
                                            case 1:
                                                _a.sent();
                                                return [3 /*break*/, 3];
                                            case 2:
                                                e_1 = _a.sent();
                                                console.error('could not send deposit', e_1);
                                                return [3 /*break*/, 3];
                                            case 3: return [2 /*return*/];
                                        }
                                    });
                                }); }, 30);
                            }
                        };
                        for (i = 0; i < tokens.length; i++) {
                            _loop_1(i);
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    WalletClient.prototype.isEthContract = function (address) {
        return __awaiter(this, void 0, void 0, function () {
            var provider, code;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        provider = this.getEthProvider();
                        return [4 /*yield*/, provider.getCode(address)
                            // non-contract addresses should return 0x
                        ];
                    case 1:
                        code = _a.sent();
                        // non-contract addresses should return 0x
                        return [2 /*return*/, code != '0x'];
                }
            });
        });
    };
    WalletClient.prototype.getDepositFeeAmount = function (token, depositAddress) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var feeInfo, feeAmount, walletContractDeployed;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0: return [4 /*yield*/, this.getFeeInfo(token.denom)];
                    case 1:
                        feeInfo = _c.sent();
                        if (!((_b = (_a = feeInfo.details) === null || _a === void 0 ? void 0 : _a.deposit) === null || _b === void 0 ? void 0 : _b.fee)) {
                            throw new Error('unsupported token');
                        }
                        feeAmount = ethers_1.ethers.BigNumber.from(feeInfo.details.deposit.fee);
                        if (!(token.blockchain == constants_1.Blockchain.Ethereum)) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.isEthContract(depositAddress)];
                    case 2:
                        walletContractDeployed = _c.sent();
                        if (!walletContractDeployed) {
                            feeAmount = feeAmount.add(ethers_1.ethers.BigNumber.from(feeInfo.details.createWallet.fee));
                        }
                        _c.label = 3;
                    case 3: return [2 /*return*/, feeAmount];
                }
            });
        });
    };
    WalletClient.prototype.getWithdrawalFeeAmount = function (token) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var feeInfo;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0: return [4 /*yield*/, this.getFeeInfo(token.denom)];
                    case 1:
                        feeInfo = _c.sent();
                        if (!((_b = (_a = feeInfo.details) === null || _a === void 0 ? void 0 : _a.withdrawal) === null || _b === void 0 ? void 0 : _b.fee)) {
                            throw new Error('unsupported token');
                        }
                        return [2 /*return*/, ethers_1.ethers.BigNumber.from(feeInfo.details.withdrawal.fee)];
                }
            });
        });
    };
    WalletClient.prototype.getMinDepositAmount = function (token, depositAddress) {
        return __awaiter(this, void 0, void 0, function () {
            var fee;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getDepositFeeAmount(token, depositAddress)];
                    case 1:
                        fee = _a.sent();
                        return [2 /*return*/, fee.mul(this.feeMultiplier)];
                }
            });
        });
    };
    WalletClient.prototype.getMinWithdrawalAmount = function (token) {
        return __awaiter(this, void 0, void 0, function () {
            var fee;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getWithdrawalFeeAmount(token)];
                    case 1:
                        fee = _a.sent();
                        return [2 /*return*/, fee.mul(this.feeMultiplier)];
                }
            });
        });
    };
    WalletClient.prototype.sendEthDeposit = function (token, depositAddress) {
        return __awaiter(this, void 0, void 0, function () {
            var feeAmount, amount, assetId, targetProxyHash, feeAddress, toAssetHash, nonce, message, messageBytes, privateKey, etherWallet, owner, signature, rsv, swthAddress, body, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getDepositFeeAmount(token, depositAddress)];
                    case 1:
                        feeAmount = _a.sent();
                        amount = ethers_1.ethers.BigNumber.from(token.external_balance);
                        if (amount.lt(feeAmount.mul(this.feeMultiplier))) {
                            return [2 /*return*/, 'insufficient balance'];
                        }
                        assetId = '0x' + token.asset_id;
                        targetProxyHash = '0x' + this.getTargetProxyHash(token);
                        feeAddress = '0x' + this.network.FEE_ADDRESS;
                        toAssetHash = ethers_1.ethers.utils.hexlify(ethers_1.ethers.utils.toUtf8Bytes(token.denom));
                        nonce = Math.floor(Math.random() * 1000000000) // random nonce to prevent replay attacks
                        ;
                        message = ethers_1.ethers.utils.solidityKeccak256(['string', 'address', 'bytes', 'bytes', 'bytes', 'uint256', 'uint256', 'uint256'], ['sendTokens', assetId, targetProxyHash, toAssetHash, feeAddress, amount, feeAmount, nonce]);
                        messageBytes = ethers_1.ethers.utils.arrayify(message);
                        privateKey = this.hdWallet[constants_1.Blockchain.Ethereum];
                        etherWallet = new ethers_1.ethers.Wallet('0x' + privateKey);
                        owner = etherWallet.address;
                        return [4 /*yield*/, etherWallet.signMessage(messageBytes)];
                    case 2:
                        signature = _a.sent();
                        rsv = ethers_1.ethers.utils.splitSignature(signature);
                        swthAddress = ethers_1.ethers.utils.hexlify(this.address);
                        body = {
                            OwnerAddress: owner,
                            SwthAddress: swthAddress,
                            AssetHash: assetId,
                            TargetProxyHash: targetProxyHash,
                            ToAssetHash: toAssetHash,
                            Amount: amount.toString(),
                            FeeAmount: feeAmount.toString(),
                            FeeAddress: feeAddress,
                            Nonce: nonce.toString(),
                            V: rsv.v.toString(),
                            R: rsv.r,
                            S: rsv.s,
                        };
                        return [4 /*yield*/, node_fetch_1.default(this.network.ETH_PAYER_URL + '/deposit', { method: 'POST', body: JSON.stringify(body) })];
                    case 3:
                        result = _a.sent();
                        return [2 /*return*/, result];
                }
            });
        });
    };
    WalletClient.prototype.getDepositAddress = function (blockchain) {
        return __awaiter(this, void 0, void 0, function () {
            var depositAddress;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.depositAddresses[blockchain] !== undefined) {
                            return [2 /*return*/, this.depositAddresses[blockchain]];
                        }
                        depositAddress = '';
                        if (!(blockchain === constants_1.Blockchain.Neo)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.getNeoDepositAddress()];
                    case 1:
                        depositAddress = _a.sent();
                        return [3 /*break*/, 5];
                    case 2:
                        if (!(blockchain === constants_1.Blockchain.Ethereum)) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.getEthDepositAddress()];
                    case 3:
                        depositAddress = _a.sent();
                        return [3 /*break*/, 5];
                    case 4: return [2 /*return*/, 'unsupported blockchain'];
                    case 5:
                        this.depositAddresses[blockchain] = depositAddress;
                        return [2 /*return*/, depositAddress];
                }
            });
        });
    };
    WalletClient.prototype.getTokens = function () {
        return node_fetch_1.default(this.network.REST_URL + "/get_tokens")
            .then(function (res) { return res.json(); }); // expecting a json response
    };
    WalletClient.prototype.getNeoDepositAddress = function () {
        return __awaiter(this, void 0, void 0, function () {
            var privateKey, account;
            return __generator(this, function (_a) {
                privateKey = this.hdWallet[constants_1.Blockchain.Neo];
                account = neon_js_1.default.create.account(privateKey);
                return [2 /*return*/, account.address];
            });
        });
    };
    WalletClient.prototype.getEthDepositAddress = function () {
        return __awaiter(this, void 0, void 0, function () {
            var swthAddress, privateKey, owner, provider, contractAddress, contract, walletAddress;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        swthAddress = ethers_1.ethers.utils.hexlify(this.address);
                        privateKey = this.hdWallet[constants_1.Blockchain.Ethereum];
                        owner = (new ethers_1.ethers.Wallet('0x' + privateKey)).address;
                        provider = this.getEthProvider();
                        contractAddress = this.network.ETH_LOCKPROXY;
                        contract = new ethers_1.ethers.Contract(contractAddress, lockProxy_json_1.default, provider);
                        return [4 /*yield*/, contract.getWalletAddress(owner, swthAddress, constants_1.ETH_WALLET_BYTECODE)];
                    case 1:
                        walletAddress = _a.sent();
                        return [2 /*return*/, walletAddress];
                }
            });
        });
    };
    WalletClient.prototype.getEthProvider = function () {
        if (this.network.ETH_URL.length > 0) {
            return new ethers_1.ethers.providers.JsonRpcProvider(this.network.ETH_URL);
        }
        return ethers_1.ethers.getDefaultProvider(this.network.ETH_ENV);
    };
    WalletClient.prototype.getEthExternalBalances = function (address, whitelistDenoms) {
        return __awaiter(this, void 0, void 0, function () {
            var tokenList, tokens, assetIds, provider, contractAddress, contract, balances, i;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getTokens()];
                    case 1:
                        tokenList = _a.sent();
                        tokens = tokenList.filter(function (token) {
                            return token.blockchain == constants_1.Blockchain.Ethereum &&
                                token.asset_id.length == 40 &&
                                ('0x' + token.lock_proxy_hash).toLowerCase() == _this.network.ETH_LOCKPROXY &&
                                (!whitelistDenoms || whitelistDenoms.includes(token.denom));
                        });
                        assetIds = tokens.map(function (token) { return '0x' + token.asset_id; });
                        provider = this.getEthProvider();
                        contractAddress = this.network.ETH_BALANCE_READER;
                        contract = new ethers_1.ethers.Contract(contractAddress, balanceReader_json_1.default, provider);
                        return [4 /*yield*/, contract.getBalances(address, assetIds)];
                    case 2:
                        balances = _a.sent();
                        for (i = 0; i < tokens.length; i++) {
                            tokens[i].external_balance = balances[i].toString();
                        }
                        return [2 /*return*/, tokens];
                }
            });
        });
    };
    WalletClient.prototype.getNeoRpcUrl = function () {
        return __awaiter(this, void 0, void 0, function () {
            var response, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, node_fetch_1.default("https://api.switcheo.network/v2/network/best_node")
                                .then(function (res) { return res.json(); })];
                    case 1:
                        response = _b.sent();
                        return [2 /*return*/, response.node];
                    case 2:
                        _a = _b.sent();
                        return [2 /*return*/, this.getRandomNeoRpcUrl()];
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    WalletClient.prototype.getRandomNeoRpcUrl = function () {
        var urls = this.network.NEO_URLS;
        var index = Math.floor(Math.random() * urls.length);
        return urls[index];
    };
    WalletClient.prototype.parseHexNum = function (hex, exp) {
        if (exp === void 0) { exp = 0; }
        if (!hex || typeof (hex) !== 'string')
            return '0';
        var res = hex.length % 2 !== 0 ? "0" + hex : hex;
        return new bignumber_js_1.BigNumber(res ? neon_core_1.u.reverseHex(res) : '00', 16).shiftedBy(-exp).toString();
    };
    WalletClient.prototype.getNeoExternalBalances = function (address, url, whitelistDenoms) {
        return __awaiter(this, void 0, void 0, function () {
            var tokenList, account, tokens, client, promises, result, i, token;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getTokens()];
                    case 1:
                        tokenList = _a.sent();
                        account = new neon_core_1.wallet.Account(address);
                        tokens = tokenList.filter(function (token) {
                            return token.blockchain == constants_1.Blockchain.Neo &&
                                token.asset_id.length == 40 &&
                                token.lock_proxy_hash.length == 40;
                        });
                        client = new neon_core_1.rpc.RPCClient(url, '2.5.2') // TODO: should we change the RPC version??
                        ;
                        promises = lodash_1.chunk(tokens, 75).map(function (partition) { return __awaiter(_this, void 0, void 0, function () {
                            var acc, _i, partition_1, token, sb, response, err_1;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        acc = {};
                                        _i = 0, partition_1 = partition;
                                        _a.label = 1;
                                    case 1:
                                        if (!(_i < partition_1.length)) return [3 /*break*/, 6];
                                        token = partition_1[_i];
                                        if (whitelistDenoms && !whitelistDenoms.includes(token.denom))
                                            return [3 /*break*/, 5];
                                        sb = new neon_core_1.sc.ScriptBuilder();
                                        sb.emitAppCall(neon_js_1.default.u.reverseHex(token.asset_id), 'balanceOf', [neon_core_1.u.reverseHex(account.scriptHash)]);
                                        _a.label = 2;
                                    case 2:
                                        _a.trys.push([2, 4, , 5]);
                                        return [4 /*yield*/, client.invokeScript(sb.str)];
                                    case 3:
                                        response = _a.sent();
                                        acc[token.denom.toUpperCase()] = response.stack[0].type === 'Integer' // Happens on polychain devnet
                                            ? response.stack[0].value
                                            : this.parseHexNum(response.stack[0].value);
                                        return [3 /*break*/, 5];
                                    case 4:
                                        err_1 = _a.sent();
                                        console.error('Could not retrieve external balance for ', token.denom);
                                        console.error(err_1);
                                        return [3 /*break*/, 5];
                                    case 5:
                                        _i++;
                                        return [3 /*break*/, 1];
                                    case 6: return [2 /*return*/, acc];
                                }
                            });
                        }); });
                        return [4 /*yield*/, Promise.all(promises).then(function (results) {
                                return results.reduce(function (acc, res) { return (__assign(__assign({}, acc), res)); }, {});
                            })];
                    case 2:
                        result = _a.sent();
                        for (i = 0; i < tokens.length; i++) {
                            token = tokens[i];
                            tokens[i].external_balance = result[token.denom.toUpperCase()];
                        }
                        return [2 /*return*/, tokens];
                }
            });
        });
    };
    WalletClient.prototype.signMessage = function (msgs, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var sequence, result, result, memo, feeAmount, stdSignMsg, signatureBase64, sigData;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        sequence = options.sequence;
                        if (!(sequence === undefined || sequence === null)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.getAccount()];
                    case 1:
                        result = (_a.sent()).result;
                        sequence = result.value.sequence;
                        _a.label = 2;
                    case 2:
                        if (!(this.accountNumber === '0' || !this.accountNumber)) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.getAccount()];
                    case 3:
                        result = (_a.sent()).result;
                        this.accountNumber = result.value.account_number.toString();
                        if (this.accountNumber === '0') {
                            throw new Error('Account number still 0 after refetching. This suggests your account is not initialized with funds');
                        }
                        _a.label = 4;
                    case 4:
                        memo = options.memo || '';
                        feeAmount = (new bignumber_js_1.BigNumber(msgs.length)).shiftedBy(8).toString();
                        if (options && options.fee) {
                            feeAmount = options.fee.amount[0].amount;
                        }
                        stdSignMsg = new containers_1.StdSignDoc({
                            accountNumber: this.accountNumber,
                            chainId: this.network.CHAIN_ID,
                            fee: new containers_1.Fee([{
                                    denom: 'swth',
                                    amount: feeAmount,
                                }], this.gas),
                            memo: memo,
                            msgs: msgs,
                            sequence: sequence.toString(),
                        });
                        if (!(this.signerType === 'ledger')) return [3 /*break*/, 8];
                        if (!this.ledger) {
                            throw new Error('Ledger connection not found, please refresh the page and try again');
                        }
                        this.onRequestSign && this.onRequestSign(stdSignMsg);
                        signatureBase64 = void 0;
                        _a.label = 5;
                    case 5:
                        _a.trys.push([5, , 7, 8]);
                        return [4 /*yield*/, this.ledger.sign(encoder_1.sortAndStringifyJSON(stdSignMsg))];
                    case 6:
                        sigData = _a.sent();
                        signatureBase64 = Buffer.from(sigData).toString('base64');
                        return [2 /*return*/, {
                                pub_key: {
                                    type: 'tendermint/PubKeySecp256k1',
                                    value: this.pubKeyBase64,
                                },
                                signature: signatureBase64,
                            }];
                    case 7:
                        this.onSignComplete && this.onSignComplete(signatureBase64 && signatureBase64.toString());
                        return [7 /*endfinally*/];
                    case 8: return [2 /*return*/, this.sign(encoder_1.marshalJSON(stdSignMsg))];
                }
            });
        });
    };
    WalletClient.prototype.signAndBroadcast = function (msgs, types, options) {
        return __awaiter(this, void 0, void 0, function () {
            var concreteMsgs, signature, broadcastTxBody;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.useSequenceCounter === true)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.seqSignAndBroadcast(msgs, types, options)];
                    case 1: return [2 /*return*/, _a.sent()];
                    case 2:
                        concreteMsgs = this.constructConcreteMsgs(msgs, types);
                        return [4 /*yield*/, this.signMessage(concreteMsgs, options)];
                    case 3:
                        signature = _a.sent();
                        broadcastTxBody = new containers_1.Transaction(concreteMsgs, [signature], options);
                        return [2 /*return*/, this.broadcast(broadcastTxBody)];
                }
            });
        });
    };
    WalletClient.prototype.seqSignAndBroadcast = function (msgs, types, options) {
        return __awaiter(this, void 0, void 0, function () {
            var concreteMsgs, id, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        concreteMsgs = this.constructConcreteMsgs(msgs, types);
                        id = Math.random().toString(36).substr(2, 9);
                        this.broadcastQueue.push({ id: id, concreteMsgs: concreteMsgs, options: options });
                        _a.label = 1;
                    case 1:
                        if (!true) return [3 /*break*/, 3];
                        // sleep for broadcastQueueIntervalTime ms
                        return [4 /*yield*/, new Promise(function (resolve) { return setTimeout(resolve, 100); })];
                    case 2:
                        // sleep for broadcastQueueIntervalTime ms
                        _a.sent();
                        result = this.broadcastResults[id];
                        if (result !== undefined) {
                            if (result instanceof Error)
                                throw result;
                            delete this.broadcastResults[id];
                            return [2 /*return*/, result];
                        }
                        return [3 /*break*/, 1];
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    WalletClient.prototype.processBroadcastQueue = function () {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        return __awaiter(this, void 0, void 0, function () {
            var result, ids, allConcreteMsgs, memo, fee, ONE_SWTH_FEE, _j, id, concreteMsgs, options_1, incomingFee, newFeeAmount, currSequence, options, response, rawLogs, error, signature, broadcastTxBody, e_2, i, id, responseCopy, isInvalidSequence;
            return __generator(this, function (_k) {
                switch (_k.label) {
                    case 0:
                        if (this.broadcastQueue.length === 0) {
                            return [2 /*return*/];
                        }
                        if (this.isBroadcastQueuePaused === true) {
                            return [2 /*return*/];
                        }
                        this.isBroadcastQueuePaused = true;
                        if (!(this.sequenceCounter === undefined)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.getAccount()];
                    case 1:
                        result = (_k.sent()).result;
                        this.sequenceCounter = result.value.sequence;
                        _k.label = 2;
                    case 2:
                        ids = [];
                        allConcreteMsgs = [];
                        ONE_SWTH_FEE = "100000000";
                        while (true) {
                            if (this.broadcastQueue.length === 0) {
                                break;
                            }
                            if (allConcreteMsgs.length + this.broadcastQueue[0].concreteMsgs.length > 100) {
                                break;
                            }
                            _j = this.broadcastQueue[0], id = _j.id, concreteMsgs = _j.concreteMsgs, options_1 = _j.options;
                            if (options_1 && options_1.fee) {
                                if ((_b = (_a = fee === null || fee === void 0 ? void 0 : fee.amount) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.amount) {
                                    incomingFee = new bignumber_js_1.BigNumber((_e = (_d = (_c = options_1.fee.amount) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.amount) !== null && _e !== void 0 ? _e : ONE_SWTH_FEE);
                                    newFeeAmount = new bignumber_js_1.BigNumber((_h = (_g = (_f = fee.amount) === null || _f === void 0 ? void 0 : _f[0]) === null || _g === void 0 ? void 0 : _g.amount) !== null && _h !== void 0 ? _h : ONE_SWTH_FEE).plus(incomingFee);
                                    fee.amount[0].amount = newFeeAmount.toString(10);
                                }
                                else {
                                    fee = options_1.fee;
                                }
                            }
                            // there can only be one memo per txn
                            // so if there is a memo, we want to put it in a queue by itself
                            if (options_1 && options_1.memo !== undefined && options_1.memo.length > 0) {
                                // the queue is not empty, so we just break for now
                                if (ids.length !== 0) {
                                    break;
                                }
                                // the queue is empty, so we assign the memo
                                memo = options_1.memo;
                            }
                            ids.push(id);
                            allConcreteMsgs = allConcreteMsgs.concat(concreteMsgs);
                            // pop the first element, since we have enqueued it
                            this.broadcastQueue.shift();
                            // since there is a memo here, we just break to ensure that
                            // there will only be one msg in this batch
                            if (memo !== undefined) {
                                break;
                            }
                        }
                        currSequence = this.sequenceCounter.toString();
                        options = { sequence: currSequence, memo: memo, mode: 'block', fee: fee };
                        _k.label = 3;
                    case 3:
                        _k.trys.push([3, 6, , 7]);
                        return [4 /*yield*/, this.signMessage(allConcreteMsgs, options)];
                    case 4:
                        signature = _k.sent();
                        broadcastTxBody = new containers_1.Transaction(allConcreteMsgs, [signature], options);
                        return [4 /*yield*/, this.broadcast(broadcastTxBody)];
                    case 5:
                        response = _k.sent();
                        response.sequence = currSequence;
                        try {
                            rawLogs = JSON.parse(response.raw_log);
                        }
                        catch (e) {
                            // ignore parsing error
                        }
                        // increment sequence counter only if tx not added to chain
                        if (response.height && response.height !== '0') {
                            this.sequenceCounter++;
                        }
                        return [3 /*break*/, 7];
                    case 6:
                        e_2 = _k.sent();
                        error = e_2;
                        return [3 /*break*/, 7];
                    case 7:
                        for (i = 0; i < ids.length; i++) {
                            id = ids[i];
                            if (error) {
                                // store error as result as workaround
                                // need to develop better error handling structure
                                this.broadcastResults[id] = error;
                                continue;
                            }
                            responseCopy = JSON.parse(JSON.stringify(response));
                            if (response.logs !== undefined) {
                                responseCopy.logs = [response.logs[i]];
                            }
                            if (rawLogs !== undefined) {
                                responseCopy.raw_log = JSON.stringify([rawLogs[i]]);
                            }
                            this.broadcastResults[id] = responseCopy;
                        }
                        if (response) {
                            isInvalidSequence = response.raw_log === 'unauthorized: signature verification failed; verify correct account sequence and chain-id';
                            if (isInvalidSequence) {
                                // reset sequenceCounter
                                this.sequenceCounter = undefined;
                            }
                        }
                        this.isBroadcastQueuePaused = false;
                        return [2 /*return*/];
                }
            });
        });
    };
    WalletClient.prototype.constructConcreteMsgs = function (msgs, types) {
        if (msgs.length != types.length)
            throw new Error('Msg length is not equal to types length');
        if (msgs.length > 100)
            throw new Error('Cannot broadcast more than 100 messages in 1 transaction');
        var concreteMsgs = [];
        // format message with concrete codec type
        for (var i = 0; i < msgs.length; i++) {
            concreteMsgs[i] = {
                type: types[i],
                value: msgs[i],
            };
        }
        return concreteMsgs;
    };
    return WalletClient;
}());
exports.WalletClient = WalletClient;
function getPrivKeyFromMnemonic(mnemonic) {
    var path = wallet_1.getPath();
    var seed = bip39.mnemonicToSeedSync(mnemonic, '');
    var masterKey = bip32.fromSeed(seed);
    var hd = masterKey.derivePath(path);
    var privateKey = hd.privateKey;
    if (!privateKey) {
        throw new Error('null hd key');
    }
    return privateKey.toString('hex');
}
exports.getPrivKeyFromMnemonic = getPrivKeyFromMnemonic;
function newAccount(net) {
    var network = config_1.getNetwork(net);
    var mnemonic = bip39.generateMnemonic();
    var privateKey = getPrivKeyFromMnemonic(mnemonic);
    var pubKeyBech32 = new wallet_1.PrivKeySecp256k1(Buffer.from(privateKey, 'hex')).toPubKey().toAddress().toBech32(config_1.getBech32Prefix(network));
    return {
        mnemonic: mnemonic,
        privateKey: privateKey,
        pubKeyBech32: pubKeyBech32,
    };
}
exports.newAccount = newAccount;
function accountFromMnemonic(mnemonic, net) {
    var network = config_1.getNetwork(net);
    var privateKey = getPrivKeyFromMnemonic(mnemonic);
    var pubKeyBech32 = new wallet_1.PrivKeySecp256k1(Buffer.from(privateKey, 'hex')).toPubKey().toAddress().toBech32(config_1.getBech32Prefix(network));
    return {
        mnemonic: mnemonic,
        privateKey: privateKey,
        pubKeyBech32: pubKeyBech32,
    };
}
exports.accountFromMnemonic = accountFromMnemonic;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2FsbGV0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2xpYi9jbGllbnRzL3dhbGxldC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwyQ0FBOEI7QUFDOUIsMkNBQThCO0FBQzlCLDBEQUE4QjtBQUM5Qiw2Q0FBd0M7QUFDeEMsd0VBQTZDO0FBQzdDLGlDQUErQjtBQUMvQixvQ0FBd0U7QUFDeEUsNENBQTREO0FBQzVELDRDQUFvRTtBQUNwRSwwQ0FBcUY7QUFFckYsOENBQTRDO0FBQzVDLHNGQUErRDtBQUMvRCw4RUFBdUQ7QUFDdkQsMENBQThEO0FBQzlELDZEQUFrRDtBQUNsRCxzRUFBNkM7QUFFN0MsbURBSzhCO0FBQzlCLGlDQUE4QjtBQXFEOUI7SUE4RUUsc0JBQVksTUFBK0I7UUFBM0MsaUJBdUVDO1FBckVHLElBQUEsUUFBUSxHQWNOLE1BQU0sU0FkQSxFQUNSLFlBQVksR0FhVixNQUFNLGFBYkksRUFDWixNQUFNLEdBWUosTUFBTSxPQVpGLEVBQ04sYUFBYSxHQVdYLE1BQU0sY0FYSyxFQUNiLE9BQU8sR0FVTCxNQUFNLFFBVkQsRUFDUCxLQVNFLE1BQU0sMkJBVHdCLEVBQWhDLDBCQUEwQixtQkFBRyxHQUFHLEtBQUEsRUFDaEMsS0FRRSxNQUFNLG1CQVJpQixFQUF6QixrQkFBa0IsbUJBQUcsSUFBSSxLQUFBLEVBQ3pCLFVBQVUsR0FPUixNQUFNLFdBUEUsRUFDVixVQUFVLEdBTVIsTUFBTSxXQU5FLEVBQ1YsTUFBTSxHQUtKLE1BQU0sT0FMRixFQUNOLEtBSUUsTUFBTSxJQUpnQixFQUF4QixHQUFHLG1CQUFHLGVBQU0sQ0FBQyxXQUFXLEtBQUEsRUFDeEIsYUFBYSxHQUdYLE1BQU0sY0FISyxFQUNiLGNBQWMsR0FFWixNQUFNLGVBRk0sRUFDZCxJQUFJLEdBQ0YsTUFBTSxLQURKLENBQ0k7UUFDVixJQUFJLENBQUMsUUFBUSxJQUFJLFVBQVUsS0FBSyxVQUFVLEVBQUU7WUFDMUMsTUFBTSxJQUFJLEtBQUssQ0FBQyx1REFBdUQsQ0FBQyxDQUFBO1NBQ3pFO1FBQ0QsSUFBSSxDQUFDLFVBQVUsSUFBSSxVQUFVLEtBQUssWUFBWSxFQUFFO1lBQzlDLE1BQU0sSUFBSSxLQUFLLENBQUMsMkRBQTJELENBQUMsQ0FBQTtTQUM3RTtRQUNELElBQUksT0FBTyxDQUFBO1FBQ1gsSUFBSSxRQUFRLEVBQUU7WUFDWixJQUFNLFlBQVUsR0FBRyxzQkFBc0IsQ0FBQyxRQUFRLENBQUMsQ0FBQTtZQUNuRCxJQUFNLE9BQU8sR0FBRyxJQUFJLHlCQUFnQixDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsWUFBVSxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUE7WUFDcEUsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUE7WUFDeEIsSUFBSSxDQUFDLFFBQVEsR0FBRyxtQkFBUSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsQ0FBQTtZQUM1QyxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQTtZQUV0QixJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLENBQUE7WUFDOUMsT0FBTyxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsU0FBUyxFQUFFLENBQUE7WUFDMUMsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUE7U0FDbkU7YUFBTSxJQUFJLFVBQVUsRUFBRTtZQUNyQixJQUFJLENBQUMsT0FBTyxHQUFHLElBQUkseUJBQWdCLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQTtZQUNuRSxJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLENBQUE7WUFDOUMsT0FBTyxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsU0FBUyxFQUFFLENBQUE7WUFDMUMsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUE7U0FDbkU7YUFBTSxJQUFJLFVBQVUsS0FBSyxRQUFRLEVBQUU7WUFDbEMsT0FBTyxHQUFHLGdCQUFPLENBQUMsVUFBVSxDQUFDLHdCQUFlLENBQUMsT0FBTyxFQUFFLE1BQU0sQ0FBQyxFQUFFLFlBQVksQ0FBQyxDQUFBO1NBQzdFO2FBQU07WUFDTCxJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksd0JBQWUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQWtCLENBQUMsQ0FBQyxDQUFBO1lBQzNFLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFBO1lBQ2xFLE9BQU8sR0FBRyxnQkFBTyxDQUFDLFVBQVUsQ0FBQyx3QkFBZSxDQUFDLE9BQU8sRUFBRSxNQUFNLENBQUMsRUFBRSxZQUFZLENBQUMsQ0FBQTtTQUM3RTtRQUNELElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFBO1FBQ2hCLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFBO1FBQ2hDLElBQUksQ0FBQyxVQUFVLEdBQUcsMEJBQWMsQ0FBQyxlQUFNLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQTtRQUNwRSxJQUFJLENBQUMsWUFBWSxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsd0JBQWUsQ0FBQyxPQUFPLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQTtRQUN0RSxJQUFJLENBQUMsZUFBZSxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsd0JBQWUsQ0FBQyxPQUFPLEVBQUUsV0FBVyxDQUFDLENBQUMsQ0FBQTtRQUM5RSxJQUFJLENBQUMsZUFBZSxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsd0JBQWUsQ0FBQyxPQUFPLEVBQUUsV0FBVyxDQUFDLENBQUMsQ0FBQTtRQUU5RSxJQUFJLENBQUMsVUFBVSxHQUFHLFVBQVUsQ0FBQTtRQUM1QixJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQTtRQUNkLElBQUksQ0FBQyxhQUFhLEdBQUcsYUFBYSxDQUFBO1FBQ2xDLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFBO1FBQ3RCLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxFQUFFLENBQUE7UUFDMUIsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUE7UUFDcEIsSUFBSSxDQUFDLGFBQWEsR0FBRyxhQUFhLENBQUE7UUFDbEMsSUFBSSxDQUFDLGNBQWMsR0FBRyxjQUFjLENBQUE7UUFDcEMsSUFBSSxDQUFDLGFBQWEsR0FBRyxlQUFNLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQTtRQUU3QyxJQUFJLENBQUMsa0JBQWtCLEdBQUcsa0JBQWtCLENBQUE7UUFDNUMsSUFBSSxDQUFDLDBCQUEwQixHQUFHLDBCQUEwQixDQUFBO1FBQzVELElBQUksQ0FBQyxjQUFjLEdBQUcsRUFBRSxDQUFBO1FBQ3hCLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxFQUFFLENBQUE7UUFFMUIsSUFBSSxDQUFDLHdCQUF3QixHQUFRLFdBQVcsQ0FBQztZQUMvQyxLQUFJLENBQUMscUJBQXFCLEVBQUUsQ0FBQTtRQUM5QixDQUFDLEVBQUUsSUFBSSxDQUFDLDBCQUEwQixDQUFDLENBQUE7SUFDckMsQ0FBQztJQXBKbUIsNEJBQWUsR0FBbkMsVUFBb0MsUUFBZ0IsRUFBRSxHQUFZOzs7O2dCQUMxRCxPQUFPLEdBQUcsbUJBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQTtnQkFDL0Isc0JBQU8sSUFBSSxZQUFZLENBQUM7d0JBQ3RCLFFBQVEsVUFBQTt3QkFDUixPQUFPLFNBQUE7d0JBQ1AsVUFBVSxFQUFFLFVBQVU7cUJBQ3ZCLENBQUMsRUFBQTs7O0tBQ0g7SUFFbUIsOEJBQWlCLEdBQXJDLFVBQXNDLFVBQWtCLEVBQUUsR0FBWTs7OztnQkFDOUQsT0FBTyxHQUFHLG1CQUFVLENBQUMsR0FBRyxDQUFDLENBQUE7Z0JBQy9CLHNCQUFPLElBQUksWUFBWSxDQUFDO3dCQUN0QixVQUFVLFlBQUE7d0JBQ1YsT0FBTyxTQUFBO3dCQUNQLFVBQVUsRUFBRSxZQUFZO3FCQUN6QixDQUFDLEVBQUE7OztLQUNIO0lBRW1CLDBCQUFhLEdBQWpDLFVBQWtDLFlBQTBCLEVBQUUsR0FBZSxFQUMzRSxhQUFvQyxFQUNwQyxjQUFzQztRQUZzQixvQkFBQSxFQUFBLGVBQWU7Ozs7Ozt3QkFHckUsT0FBTyxHQUFHLG1CQUFVLENBQUMsR0FBRyxDQUFDLENBQUE7d0JBQ1YscUJBQU0sWUFBWSxDQUFDLGdCQUFnQixFQUFFLEVBQUE7O3dCQUFwRCxZQUFZLEdBQUcsU0FBcUM7d0JBQzNDLHFCQUFNLFlBQVksQ0FBQyxTQUFTLEVBQUUsRUFBQTs7d0JBQXZDLE1BQU0sR0FBRyxTQUE4Qjt3QkFFN0Msc0JBQU8sSUFBSSxZQUFZLENBQUM7Z0NBQ3RCLE1BQU0sRUFBRSxZQUFZO2dDQUNwQixPQUFPLFNBQUE7Z0NBQ1AsTUFBTSxRQUFBO2dDQUNOLFlBQVksY0FBQTtnQ0FDWixVQUFVLEVBQUUsUUFBUTtnQ0FDcEIsYUFBYSxlQUFBO2dDQUNiLGNBQWMsZ0JBQUE7NkJBQ2YsQ0FBQyxFQUFBOzs7O0tBQ0g7SUFFRCxpQkFBaUI7SUFDRyw2QkFBZ0IsR0FBcEMsVUFBcUMsWUFBb0IsRUFBRSxHQUFZOzs7O2dCQUMvRCxPQUFPLEdBQUcsbUJBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQTtnQkFDL0Isc0JBQU8sSUFBSSxZQUFZLENBQUM7d0JBQ3RCLE9BQU8sU0FBQTt3QkFDUCxZQUFZLGNBQUE7d0JBQ1osVUFBVSxFQUFFLFFBQVE7cUJBQ3JCLENBQUMsRUFBQTs7O0tBQ0g7SUEwR00saUNBQVUsR0FBakI7UUFDRSxhQUFhLENBQUMsSUFBSSxDQUFDLHdCQUF3QixDQUFDLENBQUE7UUFDNUMsYUFBYSxDQUFDLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxDQUFBO0lBQzNDLENBQUM7SUFFTSwyQkFBSSxHQUFYLFVBQVksT0FBTztRQUNqQixJQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFBO1FBQzVCLElBQU0sSUFBSSxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUE7UUFDbEMsSUFBTSxlQUFlLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFBO1FBQ3RFLE9BQU87WUFDTCxPQUFPLEVBQUU7Z0JBQ1AsSUFBSSxFQUFFLDRCQUE0QjtnQkFDbEMsS0FBSyxFQUFFLElBQUksQ0FBQyxZQUFZO2FBQ3pCO1lBQ0QsU0FBUyxFQUFFLGVBQWU7U0FDM0IsQ0FBQTtJQUNILENBQUM7SUFFTSxpQ0FBVSxHQUFqQixVQUFrQixNQUFrQjtRQUNsQyxJQUFJLE1BQU0sQ0FBQyxJQUFJLEVBQUU7WUFDZixJQUFJLENBQUMsSUFBSSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUE7U0FDeEI7UUFFRCxJQUFJLE1BQU0sQ0FBQyxhQUFhLEVBQUU7WUFDeEIsSUFBSSxDQUFDLGFBQWEsR0FBRyxNQUFNLENBQUMsYUFBYSxDQUFBO1NBQzFDO0lBQ0gsQ0FBQztJQUVNLGdDQUFTLEdBQWhCLFVBQWlCLElBQUk7UUFDbkIsT0FBTyxvQkFBSyxDQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxTQUFNLEVBQUUsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUM7YUFDekYsSUFBSSxDQUFDLFVBQUEsR0FBRyxJQUFJLE9BQUEsR0FBRyxDQUFDLElBQUksRUFBRSxFQUFWLENBQVUsQ0FBQyxDQUFBLENBQUMsNEJBQTRCO0lBQ3pELENBQUM7SUFFTSxpQ0FBVSxHQUFqQjtRQUNFLE9BQU8sb0JBQUssQ0FBSSxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsNkJBQXdCLElBQUksQ0FBQyxZQUFjLENBQUM7YUFDOUUsSUFBSSxDQUFDLFVBQUEsR0FBRyxJQUFJLE9BQUEsR0FBRyxDQUFDLElBQUksRUFBRSxFQUFWLENBQVUsQ0FBQyxDQUFBLENBQUMsNEJBQTRCO0lBQ3pELENBQUM7SUFFTSx1Q0FBZ0IsR0FBdkI7UUFDRSxPQUFPLG9CQUFLLENBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLDZCQUF3QixJQUFJLENBQUMsWUFBYyxDQUFDO2FBQzlFLElBQUksQ0FBQyxVQUFBLEdBQUcsSUFBSSxPQUFBLEdBQUcsQ0FBQyxJQUFJLEVBQUUsRUFBVixDQUFVLENBQUMsQ0FBQSxDQUFDLDRCQUE0QjtJQUN6RCxDQUFDO0lBRU0sbUNBQVksR0FBbkI7UUFDRSxPQUFPLG9CQUFLLENBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLHdDQUFtQyxJQUFJLENBQUMsWUFBYyxDQUFDO2FBQ3pGLElBQUksQ0FBQyxVQUFBLEdBQUcsSUFBSSxPQUFBLEdBQUcsQ0FBQyxJQUFJLEVBQUUsRUFBVixDQUFVLENBQUMsQ0FBQSxDQUFDLDRCQUE0QjtJQUN6RCxDQUFDO0lBRVksNENBQXFCLEdBQWxDLFVBQW1DLGVBQTBCOzs7Z0JBQzNELElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxlQUFlLENBQUMsQ0FBQTtnQkFDNUMsSUFBSSxDQUFDLHNCQUFzQixDQUFDLGVBQWUsQ0FBQyxDQUFBOzs7O0tBQzdDO0lBRVksNkNBQXNCLEdBQW5DLFVBQW9DLGVBQTBCOzs7Ozs7NEJBQzVDLHFCQUFNLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxzQkFBVSxDQUFDLEdBQUcsQ0FBQyxFQUFBOzt3QkFBdEQsT0FBTyxHQUFHLFNBQTRDO3dCQUM1RCxxQkFBTSxJQUFJLENBQUMsZUFBZSxDQUFDLE9BQU8sRUFBRSxlQUFlLENBQUM7NEJBRXBELHlCQUF5QjswQkFGMkI7O3dCQUFwRCxTQUFvRCxDQUFBO3dCQUVwRCx5QkFBeUI7d0JBQ3pCLElBQUksQ0FBQyxxQkFBcUIsR0FBUSxXQUFXLENBQUM7NEJBQzVDLEtBQUksQ0FBQyxlQUFlLENBQUMsT0FBTyxFQUFFLGVBQWUsQ0FBQyxDQUFBO3dCQUNoRCxDQUFDLEVBQUUsRUFBRSxHQUFHLElBQUksQ0FBQyxDQUFBOzs7OztLQUNkO0lBRVksc0NBQWUsR0FBNUIsVUFBNkIsT0FBTyxFQUFFLGVBQTBCOzs7Ozs0QkFDbEQscUJBQU0sSUFBSSxDQUFDLFlBQVksRUFBRSxFQUFBOzt3QkFBL0IsR0FBRyxHQUFHLFNBQXlCO3dCQUV4QixxQkFBTSxJQUFJLENBQUMsc0JBQXNCLENBQUMsT0FBTyxFQUFFLEdBQUcsRUFBRSxlQUFlLENBQUMsRUFBQTs7d0JBQXpFLE1BQU0sR0FBRyxTQUFnRTt3QkFDcEUsQ0FBQyxHQUFHLENBQUM7Ozs2QkFBRSxDQUFBLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFBO3dCQUN6QixLQUFLLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFBOzZCQUNuQixDQUFBLEtBQUssQ0FBQyxnQkFBZ0IsS0FBSyxTQUFTLElBQUksS0FBSyxDQUFDLGdCQUFnQixLQUFLLEdBQUcsQ0FBQSxFQUF0RSx3QkFBc0U7d0JBQ2xFLFNBQVMsR0FBRyxlQUFNLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQTt3QkFDcEQscUJBQU0sSUFBSSxDQUFDLGNBQWMsQ0FBQyxLQUFLLEVBQUUsU0FBUyxDQUFDLEVBQUE7O3dCQUEzQyxTQUEyQyxDQUFBOzs7d0JBSlosQ0FBQyxFQUFFLENBQUE7Ozs7OztLQU92QztJQUVNLHlDQUFrQixHQUF6QixVQUEwQixLQUFLO1FBQzdCLElBQU0sTUFBTSxHQUFHLHdCQUFlLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxNQUFNLENBQUMsQ0FBQTtRQUNwRCxJQUFNLE9BQU8sR0FBRyxnQkFBTyxDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFBO1FBQzVELElBQU0sWUFBWSxHQUFHLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQTtRQUN0QyxJQUFNLFVBQVUsR0FBRywwQkFBYyxDQUFDLGVBQU0sQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUE7UUFDckUsT0FBTyxVQUFVLENBQUE7SUFDbkIsQ0FBQztJQUVZLGlDQUFVLEdBQXZCLFVBQXdCLEtBQWE7Ozs7Ozt3QkFDN0IsR0FBRyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxHQUFHLGNBQWMsR0FBRyxLQUFLLENBQUE7d0JBQzFDLHFCQUFNLG9CQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQUEsR0FBRyxJQUFJLE9BQUEsR0FBRyxDQUFDLElBQUksRUFBRSxFQUFWLENBQVUsQ0FBQyxFQUFBOzt3QkFBakQsTUFBTSxHQUFHLFNBQXFEO3dCQUNwRSxzQkFBTyxNQUFNLEVBQUE7Ozs7S0FDZDtJQUVZLHFDQUFjLEdBQTNCLFVBQTRCLEtBQUssRUFBRSxjQUFjLEVBQUUsV0FBa0I7UUFBbEIsNEJBQUEsRUFBQSxrQkFBa0I7Ozs7Ozt3QkFDN0QsVUFBVSxHQUFHLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxzQkFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFBO3dCQUN4RSxPQUFPLEdBQUcsaUJBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFBO3dCQUV6QyxVQUFVLEdBQUcsV0FBQyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsZUFBZSxDQUFDLENBQUE7d0JBRWhELGFBQWEsR0FBRyxLQUFLLENBQUMsUUFBUSxDQUFBO3dCQUM5QixXQUFXLEdBQUcsV0FBQyxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUE7d0JBQzlDLGVBQWUsR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsS0FBSyxDQUFDLENBQUE7d0JBQ2hELFdBQVcsR0FBRyxXQUFDLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQTt3QkFDMUMsU0FBUyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUE7d0JBRTNCLE1BQU0sR0FBRyxlQUFNLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsQ0FBQTt3QkFDdEQsU0FBUyxHQUFHLGVBQU0sQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLGNBQWMsYUFBZCxjQUFjLGNBQWQsY0FBYyxHQUFJLFdBQVcsQ0FBQyxDQUFBO3dCQUNoRSxVQUFVLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUE7d0JBQ3JDLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxPQUFPLENBQUMsQ0FBQTt3QkFFakQsSUFBSSxNQUFNLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxFQUFFOzRCQUN4QixzQkFBTyxLQUFLLEVBQUE7eUJBQ2I7d0JBRUssRUFBRSxHQUFHLGlCQUFJLENBQUMsTUFBTSxDQUFDLGFBQWEsRUFBRSxDQUFBO3dCQUN0QyxFQUFFLENBQUMsV0FBVyxDQUFDLFVBQVUsRUFBRSxNQUFNLEVBQUU7NEJBQ2pDLGFBQWE7NEJBQ2IsV0FBVzs0QkFDWCxlQUFlOzRCQUNmLFdBQVc7NEJBQ1gsU0FBUzs0QkFDVCxNQUFNLENBQUMsUUFBUSxFQUFFOzRCQUNqQixTQUFTLENBQUMsUUFBUSxFQUFFOzRCQUNwQixVQUFVOzRCQUNWLEtBQUs7eUJBQ04sQ0FBQyxDQUFBO3dCQUVhLHFCQUFNLElBQUksQ0FBQyxZQUFZLEVBQUUsRUFBQTs7d0JBQWxDLE1BQU0sR0FBRyxTQUF5Qjt3QkFDbEMsV0FBVyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxLQUFLLFNBQVMsQ0FBQyxDQUFDOzRCQUNuRCxJQUFJLGFBQUcsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLDhCQUE4QixDQUFDOzRCQUN2RCxDQUFDLENBQUMsSUFBSSxhQUFHLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQTt3QkFDbkMsc0JBQU8saUJBQUksQ0FBQyxRQUFRLENBQUM7Z0NBQ25CLEdBQUcsRUFBRSxXQUFXO2dDQUNoQixHQUFHLEVBQUUsTUFBTTtnQ0FDWCxPQUFPLFNBQUE7Z0NBQ1AsTUFBTSxFQUFFLEVBQUUsQ0FBQyxHQUFHO2dDQUNkLEdBQUcsRUFBRSxDQUFDO2dDQUNOLElBQUksRUFBRSxDQUFDOzZCQUNSLENBQUMsRUFBQTs7OztLQUNIO0lBRVksNkNBQXNCLEdBQW5DLFVBQW9DLGVBQTBCOzs7Ozs7NEJBQzVDLHFCQUFNLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxzQkFBVSxDQUFDLFFBQVEsQ0FBQzt3QkFDakUsc0JBQXNCO3NCQUQyQzs7d0JBQTNELE9BQU8sR0FBRyxTQUFpRDt3QkFDakUsc0JBQXNCO3dCQUN0QixxQkFBTSxJQUFJLENBQUMsZUFBZSxDQUFDLE9BQU8sRUFBRSxlQUFlLENBQUMsRUFBQTs7d0JBRHBELHNCQUFzQjt3QkFDdEIsU0FBb0QsQ0FBQTt3QkFFOUMsTUFBTSxHQUFHLElBQUksb0JBQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFBO3dCQUNsRCwrQkFBK0I7d0JBQy9CLE1BQU0sQ0FBQyxFQUFFLENBQUMsaUJBQWUsT0FBTyxXQUFRLEVBQUU7NEJBQ3hDLEtBQUksQ0FBQyxlQUFlLENBQUMsT0FBTyxFQUFFLGVBQWUsQ0FBQyxDQUFBO3dCQUNoRCxDQUFDLENBQUMsQ0FBQTt3QkFHSSxXQUFXLEdBQUcsb0VBQW9FLENBQUE7d0JBQ3hGLE1BQU0sQ0FBQyxFQUFFLENBQUMseUJBQXVCLFdBQVcsV0FBTSxPQUFPLE9BQUksRUFBRTs0QkFDN0QsS0FBSSxDQUFDLGVBQWUsQ0FBQyxPQUFPLEVBQUUsZUFBZSxDQUFDLENBQUE7d0JBQ2hELENBQUMsQ0FBQyxDQUFBOzs7OztLQUNIO0lBRVksc0NBQWUsR0FBNUIsVUFBNkIsT0FBTyxFQUFFLGVBQTBCOzs7Ozs7NEJBQy9DLHFCQUFNLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxPQUFPLEVBQUUsZUFBZSxDQUFDLEVBQUE7O3dCQUFwRSxNQUFNLEdBQUcsU0FBMkQ7NENBQ2pFLENBQUM7NEJBQ1IsSUFBTSxLQUFLLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFBOzRCQUN2QixJQUFNLE9BQU8sR0FBRyxlQUFNLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsQ0FBQTs0QkFDN0QsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsRUFBRTtnQ0FDckIsc0VBQXNFO2dDQUN0RSx5RUFBeUU7Z0NBQ3pFLDBFQUEwRTtnQ0FDMUUsOEJBQThCO2dDQUM5QixVQUFVLENBQUM7Ozs7OztnREFFUCxxQkFBTSxJQUFJLENBQUMsY0FBYyxDQUFDLEtBQUssRUFBRSxPQUFPLENBQUMsRUFBQTs7Z0RBQXpDLFNBQXlDLENBQUE7Ozs7Z0RBRXpDLE9BQU8sQ0FBQyxLQUFLLENBQUMsd0JBQXdCLEVBQUUsR0FBQyxDQUFDLENBQUE7Ozs7O3FDQUU3QyxFQUFFLEVBQUUsQ0FBQyxDQUFBOzZCQUNQOzt3QkFmSCxLQUFTLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFO29DQUE3QixDQUFDO3lCQWdCVDs7Ozs7S0FDRjtJQUVZLG9DQUFhLEdBQTFCLFVBQTJCLE9BQU87Ozs7Ozt3QkFDMUIsUUFBUSxHQUFHLElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQTt3QkFDekIscUJBQU0sUUFBUSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUM7NEJBQzVDLDBDQUEwQzswQkFERTs7d0JBQXRDLElBQUksR0FBRyxTQUErQjt3QkFDNUMsMENBQTBDO3dCQUMxQyxzQkFBTyxJQUFJLElBQUksSUFBSSxFQUFBOzs7O0tBQ3BCO0lBRVksMENBQW1CLEdBQWhDLFVBQWlDLEtBQUssRUFBRSxjQUFjOzs7Ozs7NEJBQ3BDLHFCQUFNLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxFQUFBOzt3QkFBNUMsT0FBTyxHQUFHLFNBQWtDO3dCQUNsRCxJQUFJLGNBQUMsT0FBTyxDQUFDLE9BQU8sMENBQUUsT0FBTywwQ0FBRSxHQUFHLENBQUEsRUFBRTs0QkFDbEMsTUFBTSxJQUFJLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxDQUFBO3lCQUNyQzt3QkFFRyxTQUFTLEdBQUcsZUFBTSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUE7NkJBQzlELENBQUEsS0FBSyxDQUFDLFVBQVUsSUFBSSxzQkFBVSxDQUFDLFFBQVEsQ0FBQSxFQUF2Qyx3QkFBdUM7d0JBQ1YscUJBQU0sSUFBSSxDQUFDLGFBQWEsQ0FBQyxjQUFjLENBQUMsRUFBQTs7d0JBQWpFLHNCQUFzQixHQUFHLFNBQXdDO3dCQUN2RSxJQUFJLENBQUMsc0JBQXNCLEVBQUU7NEJBQzNCLFNBQVMsR0FBRyxTQUFTLENBQUMsR0FBRyxDQUFDLGVBQU0sQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUE7eUJBQ25GOzs0QkFHSCxzQkFBTyxTQUFTLEVBQUE7Ozs7S0FDakI7SUFFWSw2Q0FBc0IsR0FBbkMsVUFBb0MsS0FBSzs7Ozs7OzRCQUN2QixxQkFBTSxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsRUFBQTs7d0JBQTVDLE9BQU8sR0FBRyxTQUFrQzt3QkFDbEQsSUFBSSxjQUFDLE9BQU8sQ0FBQyxPQUFPLDBDQUFFLFVBQVUsMENBQUUsR0FBRyxDQUFBLEVBQUU7NEJBQ3JDLE1BQU0sSUFBSSxLQUFLLENBQUMsbUJBQW1CLENBQUMsQ0FBQTt5QkFDckM7d0JBRUQsc0JBQU8sZUFBTSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLEVBQUE7Ozs7S0FDN0Q7SUFFWSwwQ0FBbUIsR0FBaEMsVUFBaUMsS0FBSyxFQUFFLGNBQWM7Ozs7OzRCQUN4QyxxQkFBTSxJQUFJLENBQUMsbUJBQW1CLENBQUMsS0FBSyxFQUFFLGNBQWMsQ0FBQyxFQUFBOzt3QkFBM0QsR0FBRyxHQUFHLFNBQXFEO3dCQUNqRSxzQkFBTyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsRUFBQTs7OztLQUNuQztJQUVZLDZDQUFzQixHQUFuQyxVQUFvQyxLQUFLOzs7Ozs0QkFDM0IscUJBQU0sSUFBSSxDQUFDLHNCQUFzQixDQUFDLEtBQUssQ0FBQyxFQUFBOzt3QkFBOUMsR0FBRyxHQUFHLFNBQXdDO3dCQUNwRCxzQkFBTyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsRUFBQTs7OztLQUNuQztJQUVZLHFDQUFjLEdBQTNCLFVBQTRCLEtBQUssRUFBRSxjQUFjOzs7Ozs0QkFDN0IscUJBQU0sSUFBSSxDQUFDLG1CQUFtQixDQUFDLEtBQUssRUFBRSxjQUFjLENBQUMsRUFBQTs7d0JBQWpFLFNBQVMsR0FBRyxTQUFxRDt3QkFDakUsTUFBTSxHQUFHLGVBQU0sQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFBO3dCQUM1RCxJQUFJLE1BQU0sQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsRUFBRTs0QkFDaEQsc0JBQU8sc0JBQXNCLEVBQUE7eUJBQzlCO3dCQUVLLE9BQU8sR0FBRyxJQUFJLEdBQUcsS0FBSyxDQUFDLFFBQVEsQ0FBQTt3QkFDL0IsZUFBZSxHQUFHLElBQUksR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsS0FBSyxDQUFDLENBQUE7d0JBQ3ZELFVBQVUsR0FBRyxJQUFJLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUE7d0JBQzVDLFdBQVcsR0FBRyxlQUFNLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxlQUFNLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQTt3QkFDekUsS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLFVBQVUsQ0FBQyxDQUFDLHlDQUF5Qzt3QkFBMUMsQ0FBQTt3QkFDOUMsT0FBTyxHQUFHLGVBQU0sQ0FBQyxLQUFLLENBQUMsaUJBQWlCLENBQzVDLENBQUMsUUFBUSxFQUFFLFNBQVMsRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLFNBQVMsQ0FBQyxFQUNqRixDQUFDLFlBQVksRUFBRSxPQUFPLEVBQUUsZUFBZSxFQUFFLFdBQVcsRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFLFNBQVMsRUFBRSxLQUFLLENBQUMsQ0FDNUYsQ0FBQTt3QkFDSyxZQUFZLEdBQUcsZUFBTSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUE7d0JBRTdDLFVBQVUsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLHNCQUFVLENBQUMsUUFBUSxDQUFDLENBQUE7d0JBQy9DLFdBQVcsR0FBRyxJQUFJLGVBQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxHQUFHLFVBQVUsQ0FBQyxDQUFBO3dCQUNsRCxLQUFLLEdBQUcsV0FBVyxDQUFDLE9BQU8sQ0FBQTt3QkFDZixxQkFBTSxXQUFXLENBQUMsV0FBVyxDQUFDLFlBQVksQ0FBQyxFQUFBOzt3QkFBdkQsU0FBUyxHQUFHLFNBQTJDO3dCQUN2RCxHQUFHLEdBQUcsZUFBTSxDQUFDLEtBQUssQ0FBQyxjQUFjLENBQUMsU0FBUyxDQUFDLENBQUE7d0JBRTVDLFdBQVcsR0FBRyxlQUFNLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUE7d0JBQ2hELElBQUksR0FBRzs0QkFDWCxZQUFZLEVBQUUsS0FBSzs0QkFDbkIsV0FBVyxFQUFFLFdBQVc7NEJBQ3hCLFNBQVMsRUFBRSxPQUFPOzRCQUNsQixlQUFlLEVBQUUsZUFBZTs0QkFDaEMsV0FBVyxFQUFFLFdBQVc7NEJBQ3hCLE1BQU0sRUFBRSxNQUFNLENBQUMsUUFBUSxFQUFFOzRCQUN6QixTQUFTLEVBQUUsU0FBUyxDQUFDLFFBQVEsRUFBRTs0QkFDL0IsVUFBVSxFQUFFLFVBQVU7NEJBQ3RCLEtBQUssRUFBRSxLQUFLLENBQUMsUUFBUSxFQUFFOzRCQUN2QixDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUU7NEJBQ25CLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQzs0QkFDUixDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7eUJBQ1QsQ0FBQTt3QkFFYyxxQkFBTSxvQkFBSyxDQUN4QixJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsR0FBRyxVQUFVLEVBQ3ZDLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUMvQyxFQUFBOzt3QkFISyxNQUFNLEdBQUcsU0FHZDt3QkFDRCxzQkFBTyxNQUFNLEVBQUE7Ozs7S0FDZDtJQUVZLHdDQUFpQixHQUE5QixVQUErQixVQUFrQjs7Ozs7O3dCQUMvQyxJQUFJLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLENBQUMsS0FBSyxTQUFTLEVBQUU7NEJBQ25ELHNCQUFPLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLENBQUMsRUFBQTt5QkFDekM7d0JBRUcsY0FBYyxHQUFHLEVBQUUsQ0FBQTs2QkFDbkIsQ0FBQSxVQUFVLEtBQUssc0JBQVUsQ0FBQyxHQUFHLENBQUEsRUFBN0Isd0JBQTZCO3dCQUNkLHFCQUFNLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxFQUFBOzt3QkFBbEQsY0FBYyxHQUFHLFNBQWlDLENBQUE7Ozs2QkFDekMsQ0FBQSxVQUFVLEtBQUssc0JBQVUsQ0FBQyxRQUFRLENBQUEsRUFBbEMsd0JBQWtDO3dCQUMxQixxQkFBTSxJQUFJLENBQUMsb0JBQW9CLEVBQUUsRUFBQTs7d0JBQWxELGNBQWMsR0FBRyxTQUFpQyxDQUFBOzs0QkFFbEQsc0JBQU8sd0JBQXdCLEVBQUE7O3dCQUdqQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsVUFBVSxDQUFDLEdBQUcsY0FBYyxDQUFBO3dCQUNsRCxzQkFBTyxjQUFjLEVBQUE7Ozs7S0FDdEI7SUFFTSxnQ0FBUyxHQUFoQjtRQUNFLE9BQU8sb0JBQUssQ0FBSSxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsZ0JBQWEsQ0FBQzthQUNoRCxJQUFJLENBQUMsVUFBQSxHQUFHLElBQUksT0FBQSxHQUFHLENBQUMsSUFBSSxFQUFFLEVBQVYsQ0FBVSxDQUFDLENBQUEsQ0FBQyw0QkFBNEI7SUFDekQsQ0FBQztJQUdZLDJDQUFvQixHQUFqQzs7OztnQkFDUSxVQUFVLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxzQkFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFBO2dCQUMxQyxPQUFPLEdBQUcsaUJBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFBO2dCQUMvQyxzQkFBTyxPQUFPLENBQUMsT0FBTyxFQUFBOzs7S0FDdkI7SUFFWSwyQ0FBb0IsR0FBakM7Ozs7Ozt3QkFDUSxXQUFXLEdBQUcsZUFBTSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFBO3dCQUNoRCxVQUFVLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxzQkFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFBO3dCQUMvQyxLQUFLLEdBQUcsQ0FBQyxJQUFJLGVBQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxHQUFHLFVBQVUsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFBO3dCQUV0RCxRQUFRLEdBQUcsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFBO3dCQUNoQyxlQUFlLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUE7d0JBQzVDLFFBQVEsR0FBRyxJQUFJLGVBQU0sQ0FBQyxRQUFRLENBQUMsZUFBZSxFQUFFLHdCQUFjLEVBQUUsUUFBUSxDQUFDLENBQUE7d0JBQ3pELHFCQUFNLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLEVBQUUsV0FBVyxFQUFFLCtCQUFtQixDQUFDLEVBQUE7O3dCQUF4RixhQUFhLEdBQUcsU0FBd0U7d0JBRTlGLHNCQUFPLGFBQWEsRUFBQTs7OztLQUNyQjtJQUVNLHFDQUFjLEdBQXJCO1FBQ0UsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQ25DLE9BQU8sSUFBSSxlQUFNLENBQUMsU0FBUyxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFBO1NBQ2xFO1FBQ0QsT0FBTyxlQUFNLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQTtJQUN4RCxDQUFDO0lBRVksNkNBQXNCLEdBQW5DLFVBQW9DLE9BQWUsRUFBRSxlQUEwQjs7Ozs7OzRCQUMzRCxxQkFBTSxJQUFJLENBQUMsU0FBUyxFQUFFLEVBQUE7O3dCQUFsQyxTQUFTLEdBQUcsU0FBc0I7d0JBQ2xDLE1BQU0sR0FBRyxTQUFTLENBQUMsTUFBTSxDQUFDLFVBQUEsS0FBSzs0QkFDbkMsT0FBQSxLQUFLLENBQUMsVUFBVSxJQUFJLHNCQUFVLENBQUMsUUFBUTtnQ0FDdkMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxNQUFNLElBQUksRUFBRTtnQ0FDM0IsQ0FBQyxJQUFJLEdBQUcsS0FBSyxDQUFDLGVBQWUsQ0FBQyxDQUFDLFdBQVcsRUFBRSxJQUFJLEtBQUksQ0FBQyxPQUFPLENBQUMsYUFBYTtnQ0FDMUUsQ0FBQyxDQUFDLGVBQWUsSUFBSSxlQUFlLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQzt3QkFIM0QsQ0FHMkQsQ0FDNUQsQ0FBQTt3QkFDSyxRQUFRLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyxVQUFBLEtBQUssSUFBSSxPQUFBLElBQUksR0FBRyxLQUFLLENBQUMsUUFBUSxFQUFyQixDQUFxQixDQUFDLENBQUE7d0JBQ3JELFFBQVEsR0FBRyxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUE7d0JBQ2hDLGVBQWUsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLGtCQUFrQixDQUFBO3dCQUNqRCxRQUFRLEdBQUcsSUFBSSxlQUFNLENBQUMsUUFBUSxDQUFDLGVBQWUsRUFBRSw0QkFBa0IsRUFBRSxRQUFRLENBQUMsQ0FBQTt3QkFFbEUscUJBQU0sUUFBUSxDQUFDLFdBQVcsQ0FBQyxPQUFPLEVBQUUsUUFBUSxDQUFDLEVBQUE7O3dCQUF4RCxRQUFRLEdBQUcsU0FBNkM7d0JBQzlELEtBQVMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTs0QkFDdEMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLGdCQUFnQixHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQTt5QkFDcEQ7d0JBRUQsc0JBQU8sTUFBTSxFQUFBOzs7O0tBQ2Q7SUFFWSxtQ0FBWSxHQUF6Qjs7Ozs7Ozt3QkFFcUIscUJBQU0sb0JBQUssQ0FBQyxtREFBbUQsQ0FBQztpQ0FDOUUsSUFBSSxDQUFDLFVBQUEsR0FBRyxJQUFJLE9BQUEsR0FBRyxDQUFDLElBQUksRUFBRSxFQUFWLENBQVUsQ0FBQyxFQUFBOzt3QkFEcEIsUUFBUSxHQUFHLFNBQ1M7d0JBQzFCLHNCQUFPLFFBQVEsQ0FBQyxJQUFJLEVBQUE7Ozt3QkFFcEIsc0JBQU8sSUFBSSxDQUFDLGtCQUFrQixFQUFFLEVBQUE7Ozs7O0tBRW5DO0lBRU0seUNBQWtCLEdBQXpCO1FBQ0UsSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUE7UUFDbEMsSUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFBO1FBQ3JELE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFBO0lBQ3BCLENBQUM7SUFFTyxrQ0FBVyxHQUFuQixVQUFvQixHQUFXLEVBQUUsR0FBZTtRQUFmLG9CQUFBLEVBQUEsT0FBZTtRQUM5QyxJQUFJLENBQUMsR0FBRyxJQUFJLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxRQUFRO1lBQUUsT0FBTyxHQUFHLENBQUE7UUFDakQsSUFBTSxHQUFHLEdBQVcsR0FBRyxDQUFDLE1BQU0sR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFJLEdBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFBO1FBQzFELE9BQU8sSUFBSSx3QkFBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsYUFBUyxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFBO0lBQzdGLENBQUM7SUFFWSw2Q0FBc0IsR0FBbkMsVUFBb0MsT0FBZSxFQUFFLEdBQVcsRUFBRSxlQUEwQjs7Ozs7OzRCQUM3RCxxQkFBTSxJQUFJLENBQUMsU0FBUyxFQUFFLEVBQUE7O3dCQUE3QyxTQUFTLEdBQWMsU0FBc0I7d0JBQzdDLE9BQU8sR0FBRyxJQUFJLGtCQUFVLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFBO3dCQUN6QyxNQUFNLEdBQWMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxVQUFBLEtBQUs7NEJBQzlDLE9BQUEsS0FBSyxDQUFDLFVBQVUsSUFBSSxzQkFBVSxDQUFDLEdBQUc7Z0NBQ2xDLEtBQUssQ0FBQyxRQUFRLENBQUMsTUFBTSxJQUFJLEVBQUU7Z0NBQzNCLEtBQUssQ0FBQyxlQUFlLENBQUMsTUFBTSxJQUFJLEVBQUU7d0JBRmxDLENBRWtDLENBQ25DLENBQUE7d0JBRUssTUFBTSxHQUNWLElBQUksZUFBTyxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUUsT0FBTyxDQUFDLENBQUMsMkNBQTJDO3dCQUE1QyxDQUFBO3dCQUkvQixRQUFRLEdBQ1osY0FBSyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsVUFBTyxTQUFxQzs7Ozs7d0NBRTVELEdBQUcsR0FBRyxFQUFFLENBQUE7OENBQ2lCLEVBQVQsdUJBQVM7Ozs2Q0FBVCxDQUFBLHVCQUFTLENBQUE7d0NBQWxCLEtBQUs7d0NBQ2QsSUFBSSxlQUFlLElBQUksQ0FBQyxlQUFlLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUM7NENBQUUsd0JBQVE7d0NBQ2pFLEVBQUUsR0FBNkIsSUFBSSxjQUFVLENBQUMsYUFBYSxFQUFFLENBQUE7d0NBQ25FLEVBQUUsQ0FBQyxXQUFXLENBQUMsaUJBQUksQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsRUFDOUMsV0FBVyxFQUFFLENBQUMsYUFBUyxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFBOzs7O3dDQUd6QixxQkFBTSxNQUFNLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBQTs7d0NBQTFELFFBQVEsR0FBaUIsU0FBaUQ7d0NBQ2hGLEdBQUcsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLFdBQVcsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssU0FBUyxDQUFDLDhCQUE4Qjs0Q0FDbEcsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSzs0Q0FDekIsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQTs7Ozt3Q0FHN0MsT0FBTyxDQUFDLEtBQUssQ0FBQywwQ0FBMEMsRUFBRSxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUE7d0NBQ3RFLE9BQU8sQ0FBQyxLQUFLLENBQUMsS0FBRyxDQUFDLENBQUE7Ozt3Q0FkRixJQUFTLENBQUE7OzRDQW1CN0Isc0JBQU8sR0FBRyxFQUFBOzs7NkJBQ1gsQ0FBQyxDQUFBO3dCQUVXLHFCQUFNLE9BQU8sQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQUMsT0FBYztnQ0FDN0QsT0FBTyxPQUFPLENBQUMsTUFBTSxDQUFDLFVBQUMsR0FBTyxFQUFFLEdBQU8sSUFBSyxPQUFBLHVCQUFNLEdBQUcsR0FBSyxHQUFHLEVBQUcsRUFBcEIsQ0FBb0IsRUFBRSxFQUFFLENBQUMsQ0FBQTs0QkFDdkUsQ0FBQyxDQUFDLEVBQUE7O3dCQUZJLE1BQU0sR0FBRyxTQUViO3dCQUVGLEtBQVMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTs0QkFDaEMsS0FBSyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQTs0QkFDdkIsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLGdCQUFnQixHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUE7eUJBQy9EO3dCQUNELHNCQUFPLE1BQU0sRUFBQTs7OztLQUNkO0lBRVksa0NBQVcsR0FBeEIsVUFBeUIsSUFBbUIsRUFBRSxPQUFpQjtRQUFqQix3QkFBQSxFQUFBLFlBQWlCOzs7Ozs7d0JBQ3pELFFBQVEsR0FBVyxPQUFPLENBQUMsUUFBUSxDQUFBOzZCQUVuQyxDQUFBLFFBQVEsS0FBSyxTQUFTLElBQUksUUFBUSxLQUFLLElBQUksQ0FBQSxFQUEzQyx3QkFBMkM7d0JBQzFCLHFCQUFNLElBQUksQ0FBQyxVQUFVLEVBQUUsRUFBQTs7d0JBQWxDLE1BQU0sR0FBSyxDQUFBLFNBQXVCLENBQUEsT0FBNUI7d0JBQ2QsUUFBUSxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFBOzs7NkJBRzlCLENBQUEsSUFBSSxDQUFDLGFBQWEsS0FBSyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFBLEVBQWpELHdCQUFpRDt3QkFDaEMscUJBQU0sSUFBSSxDQUFDLFVBQVUsRUFBRSxFQUFBOzt3QkFBbEMsTUFBTSxHQUFLLENBQUEsU0FBdUIsQ0FBQSxPQUE1Qjt3QkFDZCxJQUFJLENBQUMsYUFBYSxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsY0FBYyxDQUFDLFFBQVEsRUFBRSxDQUFBO3dCQUMzRCxJQUFJLElBQUksQ0FBQyxhQUFhLEtBQUssR0FBRyxFQUFFOzRCQUM5QixNQUFNLElBQUksS0FBSyxDQUFDLG1HQUFtRyxDQUFDLENBQUE7eUJBQ3JIOzs7d0JBR0csSUFBSSxHQUFHLE9BQU8sQ0FBQyxJQUFJLElBQUksRUFBRSxDQUFBO3dCQUMzQixTQUFTLEdBQUcsQ0FBQyxJQUFJLHdCQUFTLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFBO3dCQUNwRSxJQUFJLE9BQU8sSUFBSSxPQUFPLENBQUMsR0FBRyxFQUFFOzRCQUMxQixTQUFTLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFBO3lCQUN6Qzt3QkFDSyxVQUFVLEdBQUcsSUFBSSx1QkFBVSxDQUFDOzRCQUNoQyxhQUFhLEVBQUUsSUFBSSxDQUFDLGFBQWE7NEJBQ2pDLE9BQU8sRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVE7NEJBQzlCLEdBQUcsRUFBRSxJQUFJLGdCQUFHLENBQUMsQ0FBQztvQ0FDWixLQUFLLEVBQUUsTUFBTTtvQ0FDYixNQUFNLEVBQUUsU0FBUztpQ0FDbEIsQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUM7NEJBQ2IsSUFBSSxNQUFBOzRCQUNKLElBQUksTUFBQTs0QkFDSixRQUFRLEVBQUUsUUFBUSxDQUFDLFFBQVEsRUFBRTt5QkFDOUIsQ0FBQyxDQUFBOzZCQUVFLENBQUEsSUFBSSxDQUFDLFVBQVUsS0FBSyxRQUFRLENBQUEsRUFBNUIsd0JBQTRCO3dCQUM5QixJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRTs0QkFDaEIsTUFBTSxJQUFJLEtBQUssQ0FBQyxvRUFBb0UsQ0FBQyxDQUFBO3lCQUN0Rjt3QkFDRCxJQUFJLENBQUMsYUFBYSxJQUFJLElBQUksQ0FBQyxhQUFhLENBQUMsVUFBVSxDQUFDLENBQUE7d0JBQ2hELGVBQWUsU0FBQSxDQUFBOzs7O3dCQUVELHFCQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLDhCQUFvQixDQUFDLFVBQVUsQ0FBQyxDQUFDLEVBQUE7O3dCQUFsRSxPQUFPLEdBQUcsU0FBd0Q7d0JBQ3hFLGVBQWUsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQW1CLENBQUMsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUE7d0JBQ3JFLHNCQUFPO2dDQUNMLE9BQU8sRUFBRTtvQ0FDUCxJQUFJLEVBQUUsNEJBQTRCO29DQUNsQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFlBQVk7aUNBQ3pCO2dDQUNELFNBQVMsRUFBRSxlQUFlOzZCQUMzQixFQUFBOzt3QkFFRCxJQUFJLENBQUMsY0FBYyxJQUFJLElBQUksQ0FBQyxjQUFjLENBQUMsZUFBZSxJQUFJLGVBQWUsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFBOzs0QkFHN0Ysc0JBQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxxQkFBVyxDQUFDLFVBQVUsQ0FBQyxDQUFDLEVBQUE7Ozs7S0FDMUM7SUFFWSx1Q0FBZ0IsR0FBN0IsVUFBOEIsSUFBYyxFQUFFLEtBQWUsRUFBRSxPQUFPOzs7Ozs7NkJBQ2hFLENBQUEsSUFBSSxDQUFDLGtCQUFrQixLQUFLLElBQUksQ0FBQSxFQUFoQyx3QkFBZ0M7d0JBQzNCLHFCQUFNLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLE9BQU8sQ0FBQyxFQUFBOzRCQUEzRCxzQkFBTyxTQUFvRCxFQUFBOzt3QkFHdkQsWUFBWSxHQUFHLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUE7d0JBQzFDLHFCQUFNLElBQUksQ0FBQyxXQUFXLENBQUMsWUFBWSxFQUFFLE9BQU8sQ0FBQyxFQUFBOzt3QkFBekQsU0FBUyxHQUFHLFNBQTZDO3dCQUN6RCxlQUFlLEdBQUcsSUFBSSx3QkFBVyxDQUFDLFlBQVksRUFBRSxDQUFDLFNBQVMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFBO3dCQUUzRSxzQkFBTyxJQUFJLENBQUMsU0FBUyxDQUFDLGVBQWUsQ0FBQyxFQUFBOzs7O0tBQ3ZDO0lBRVksMENBQW1CLEdBQWhDLFVBQWlDLElBQWMsRUFBRSxLQUFlLEVBQUUsT0FBTzs7Ozs7O3dCQUNqRSxZQUFZLEdBQUcsSUFBSSxDQUFDLHFCQUFxQixDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQTt3QkFDdEQsRUFBRSxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQTt3QkFDbEQsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLElBQUEsRUFBRSxZQUFZLGNBQUEsRUFBRSxPQUFPLFNBQUEsRUFBRSxDQUFDLENBQUE7Ozs2QkFFaEQsSUFBSTt3QkFDVCwwQ0FBMEM7d0JBQzFDLHFCQUFNLElBQUksT0FBTyxDQUFDLFVBQUEsT0FBTyxJQUFJLE9BQUEsVUFBVSxDQUFDLE9BQU8sRUFBRSxHQUFHLENBQUMsRUFBeEIsQ0FBd0IsQ0FBQyxFQUFBOzt3QkFEdEQsMENBQTBDO3dCQUMxQyxTQUFzRCxDQUFBO3dCQUNoRCxNQUFNLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEVBQUUsQ0FBQyxDQUFBO3dCQUN4QyxJQUFJLE1BQU0sS0FBSyxTQUFTLEVBQUU7NEJBQ3hCLElBQUksTUFBTSxZQUFZLEtBQUs7Z0NBQ3pCLE1BQU0sTUFBTSxDQUFBOzRCQUNkLE9BQU8sSUFBSSxDQUFDLGdCQUFnQixDQUFDLEVBQUUsQ0FBQyxDQUFBOzRCQUNoQyxzQkFBTyxNQUFNLEVBQUE7eUJBQ2Q7Ozs7OztLQUVKO0lBRWEsNENBQXFCLEdBQW5DOzs7Ozs7O3dCQUNFLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFOzRCQUNwQyxzQkFBTTt5QkFDUDt3QkFDRCxJQUFJLElBQUksQ0FBQyxzQkFBc0IsS0FBSyxJQUFJLEVBQUU7NEJBQ3hDLHNCQUFNO3lCQUNQO3dCQUVELElBQUksQ0FBQyxzQkFBc0IsR0FBRyxJQUFJLENBQUE7NkJBRTlCLENBQUEsSUFBSSxDQUFDLGVBQWUsS0FBSyxTQUFTLENBQUEsRUFBbEMsd0JBQWtDO3dCQUNqQixxQkFBTSxJQUFJLENBQUMsVUFBVSxFQUFFLEVBQUE7O3dCQUFsQyxNQUFNLEdBQUssQ0FBQSxTQUF1QixDQUFBLE9BQTVCO3dCQUNkLElBQUksQ0FBQyxlQUFlLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUE7Ozt3QkFHeEMsR0FBRyxHQUFHLEVBQUUsQ0FBQTt3QkFDVixlQUFlLEdBQUcsRUFBRSxDQUFBO3dCQUdsQixZQUFZLEdBQUcsV0FBVyxDQUFBO3dCQUVoQyxPQUFPLElBQUksRUFBRTs0QkFDWCxJQUFJLElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtnQ0FDcEMsTUFBSzs2QkFDTjs0QkFDRCxJQUFJLGVBQWUsQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsTUFBTSxHQUFHLEdBQUcsRUFBRTtnQ0FDN0UsTUFBSzs2QkFDTjs0QkFFSyxLQUFnQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxFQUFwRCxFQUFFLFFBQUEsRUFBRSxZQUFZLGtCQUFBLEVBQUUsc0JBQU8sQ0FBMkI7NEJBRTVELElBQUksU0FBTyxJQUFJLFNBQU8sQ0FBQyxHQUFHLEVBQUU7Z0NBQzFCLGdCQUFJLEdBQUcsYUFBSCxHQUFHLHVCQUFILEdBQUcsQ0FBRSxNQUFNLDBDQUFHLENBQUMsMkNBQUcsTUFBTSxFQUFFO29DQUt0QixXQUFXLEdBQUcsSUFBSSx3QkFBUyxtQkFBQyxTQUFPLENBQUMsR0FBRyxDQUFDLE1BQU0sMENBQUcsQ0FBQywyQ0FBRyxNQUFNLG1DQUFJLFlBQVksQ0FBQyxDQUFBO29DQUM1RSxZQUFZLEdBQUcsSUFBSSx3QkFBUyxtQkFBQyxHQUFHLENBQUMsTUFBTSwwQ0FBRyxDQUFDLDJDQUFHLE1BQU0sbUNBQUksWUFBWSxDQUFDLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFBO29DQUM3RixHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sR0FBRyxZQUFZLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFBO2lDQUNqRDtxQ0FBTTtvQ0FDTCxHQUFHLEdBQUcsU0FBTyxDQUFDLEdBQUcsQ0FBQTtpQ0FDbEI7NkJBQ0Y7NEJBRUQscUNBQXFDOzRCQUNyQyxnRUFBZ0U7NEJBQ2hFLElBQUksU0FBTyxJQUFJLFNBQU8sQ0FBQyxJQUFJLEtBQUssU0FBUyxJQUFJLFNBQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtnQ0FDcEUsbURBQW1EO2dDQUNuRCxJQUFJLEdBQUcsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO29DQUNwQixNQUFLO2lDQUNOO2dDQUVELDRDQUE0QztnQ0FDNUMsSUFBSSxHQUFHLFNBQU8sQ0FBQyxJQUFJLENBQUE7NkJBQ3BCOzRCQUVELEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUE7NEJBQ1osZUFBZSxHQUFHLGVBQWUsQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUE7NEJBRXRELG1EQUFtRDs0QkFDbkQsSUFBSSxDQUFDLGNBQWMsQ0FBQyxLQUFLLEVBQUUsQ0FBQTs0QkFFM0IsMkRBQTJEOzRCQUMzRCwyQ0FBMkM7NEJBQzNDLElBQUksSUFBSSxLQUFLLFNBQVMsRUFBRTtnQ0FDdEIsTUFBSzs2QkFDTjt5QkFDRjt3QkFFSyxZQUFZLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxRQUFRLEVBQUUsQ0FBQTt3QkFDOUMsT0FBTyxHQUFHLEVBQUUsUUFBUSxFQUFFLFlBQVksRUFBRSxJQUFJLE1BQUEsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLEdBQUcsS0FBQSxFQUFFLENBQUE7Ozs7d0JBT2hELHFCQUFNLElBQUksQ0FBQyxXQUFXLENBQUMsZUFBZSxFQUFFLE9BQU8sQ0FBQyxFQUFBOzt3QkFBNUQsU0FBUyxHQUFHLFNBQWdEO3dCQUM1RCxlQUFlLEdBQUcsSUFBSSx3QkFBVyxDQUFDLGVBQWUsRUFBRSxDQUFDLFNBQVMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFBO3dCQUVuRSxxQkFBTSxJQUFJLENBQUMsU0FBUyxDQUFDLGVBQWUsQ0FBQyxFQUFBOzt3QkFBaEQsUUFBUSxHQUFHLFNBQXFDLENBQUE7d0JBQ2hELFFBQVEsQ0FBQyxRQUFRLEdBQUcsWUFBWSxDQUFBO3dCQUVoQyxJQUFJOzRCQUNGLE9BQU8sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQTt5QkFDdkM7d0JBQUMsT0FBTyxDQUFDLEVBQUU7NEJBQ1YsdUJBQXVCO3lCQUN4Qjt3QkFFRCwyREFBMkQ7d0JBQzNELElBQUksUUFBUSxDQUFDLE1BQU0sSUFBSSxRQUFRLENBQUMsTUFBTSxLQUFLLEdBQUcsRUFBRTs0QkFDOUMsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFBO3lCQUN2Qjs7Ozt3QkFFRCxLQUFLLEdBQUcsR0FBQyxDQUFBOzs7d0JBR1gsS0FBUyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFOzRCQUM3QixFQUFFLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFBOzRCQUNqQixJQUFJLEtBQUssRUFBRTtnQ0FDVCxzQ0FBc0M7Z0NBQ3RDLGtEQUFrRDtnQ0FDbEQsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQTtnQ0FDakMsU0FBUTs2QkFDVDs0QkFDSyxZQUFZLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUE7NEJBQ3pELElBQUksUUFBUSxDQUFDLElBQUksS0FBSyxTQUFTLEVBQUU7Z0NBQy9CLFlBQVksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUE7NkJBQ3ZDOzRCQUNELElBQUksT0FBTyxLQUFLLFNBQVMsRUFBRTtnQ0FDekIsWUFBWSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQTs2QkFDcEQ7NEJBQ0QsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEVBQUUsQ0FBQyxHQUFHLFlBQVksQ0FBQTt5QkFDekM7d0JBRUQsSUFBSSxRQUFRLEVBQUU7NEJBQ04saUJBQWlCLEdBQUcsUUFBUSxDQUFDLE9BQU8sS0FBSywyRkFBMkYsQ0FBQTs0QkFDMUksSUFBSSxpQkFBaUIsRUFBRTtnQ0FDckIsd0JBQXdCO2dDQUN4QixJQUFJLENBQUMsZUFBZSxHQUFHLFNBQVMsQ0FBQTs2QkFDakM7eUJBQ0Y7d0JBRUQsSUFBSSxDQUFDLHNCQUFzQixHQUFHLEtBQUssQ0FBQTs7Ozs7S0FDcEM7SUFFTyw0Q0FBcUIsR0FBN0IsVUFBOEIsSUFBYyxFQUFFLEtBQWU7UUFDM0QsSUFBSSxJQUFJLENBQUMsTUFBTSxJQUFJLEtBQUssQ0FBQyxNQUFNO1lBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQyx5Q0FBeUMsQ0FBQyxDQUFBO1FBQzNGLElBQUksSUFBSSxDQUFDLE1BQU0sR0FBRyxHQUFHO1lBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQywwREFBMEQsQ0FBQyxDQUFBO1FBRWxHLElBQUksWUFBWSxHQUFrQixFQUFFLENBQUE7UUFDcEMsMENBQTBDO1FBQzFDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ3BDLFlBQVksQ0FBQyxDQUFDLENBQUMsR0FBRztnQkFDaEIsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7Z0JBQ2QsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUM7YUFDZixDQUFBO1NBQ0Y7UUFFRCxPQUFPLFlBQVksQ0FBQTtJQUNyQixDQUFDO0lBQ0gsbUJBQUM7QUFBRCxDQUFDLEFBdHhCRCxJQXN4QkM7QUF0eEJZLG9DQUFZO0FBd3hCekIsU0FBZ0Isc0JBQXNCLENBQUMsUUFBUTtJQUM3QyxJQUFNLElBQUksR0FBRyxnQkFBTyxFQUFFLENBQUE7SUFDdEIsSUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLGtCQUFrQixDQUFDLFFBQVEsRUFBRSxFQUFFLENBQUMsQ0FBQTtJQUNuRCxJQUFNLFNBQVMsR0FBRyxLQUFLLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFBO0lBQ3RDLElBQU0sRUFBRSxHQUFHLFNBQVMsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUE7SUFFckMsSUFBTSxVQUFVLEdBQUcsRUFBRSxDQUFDLFVBQVUsQ0FBQTtJQUNoQyxJQUFJLENBQUMsVUFBVSxFQUFFO1FBQ2YsTUFBTSxJQUFJLEtBQUssQ0FBQyxhQUFhLENBQUMsQ0FBQTtLQUMvQjtJQUNELE9BQU8sVUFBVSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQTtBQUNuQyxDQUFDO0FBWEQsd0RBV0M7QUFFRCxTQUFnQixVQUFVLENBQUMsR0FBVztJQUNwQyxJQUFNLE9BQU8sR0FBRyxtQkFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFBO0lBQy9CLElBQU0sUUFBUSxHQUFHLEtBQUssQ0FBQyxnQkFBZ0IsRUFBRSxDQUFBO0lBQ3pDLElBQU0sVUFBVSxHQUFHLHNCQUFzQixDQUFDLFFBQVEsQ0FBQyxDQUFBO0lBQ25ELElBQU0sWUFBWSxHQUFHLElBQUkseUJBQWdCLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxRQUFRLENBQUMsd0JBQWUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFBO0lBQ25JLE9BQU87UUFDTCxRQUFRLFVBQUE7UUFDUixVQUFVLFlBQUE7UUFDVixZQUFZLGNBQUE7S0FDYixDQUFBO0FBQ0gsQ0FBQztBQVZELGdDQVVDO0FBRUQsU0FBZ0IsbUJBQW1CLENBQUMsUUFBUSxFQUFFLEdBQVc7SUFDdkQsSUFBTSxPQUFPLEdBQUcsbUJBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQTtJQUMvQixJQUFNLFVBQVUsR0FBRyxzQkFBc0IsQ0FBQyxRQUFRLENBQUMsQ0FBQTtJQUNuRCxJQUFNLFlBQVksR0FBRyxJQUFJLHlCQUFnQixDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUMsU0FBUyxFQUFFLENBQUMsUUFBUSxDQUFDLHdCQUFlLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQTtJQUNuSSxPQUFPO1FBQ0wsUUFBUSxVQUFBO1FBQ1IsVUFBVSxZQUFBO1FBQ1YsWUFBWSxjQUFBO0tBQ2IsQ0FBQTtBQUNILENBQUM7QUFURCxrREFTQyJ9