"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetaMask = void 0;
var ethSignUtils = __importStar(require("eth-sig-util"));
var registry_contract_1 = __importDefault(require("./registry_contract"));
var ethers_1 = require("ethers");
var types_1 = require("../../types");
var config_1 = require("../../config");
var CONTRACT_HASH = (_a = {},
    // use same ropsten contract for all non-mainnet uses
    _a[types_1.Network.TestNet] = '0x23629C94F4e8b719094f5D1Ae1c1AA8d6d687966',
    _a[types_1.Network.DevNet] = '0x23629C94F4e8b719094f5D1Ae1c1AA8d6d687966',
    _a[types_1.Network.LocalHost] = '0x23629C94F4e8b719094f5D1Ae1c1AA8d6d687966',
    _a[types_1.Network.MainNet] = '0xf4552877A40c1527D38970F170993660084D4541',
    _a);
var ETH_CHAIN_NAMES = {
    1: 'MainNet',
    3: 'Ropsten',
};
var ENCRYPTION_VERSION = 'x25519-xsalsa20-poly1305';
var MNEMONIC_MATCH_REGEX = /-----BEGIN MNEMONIC PHRASE-----([a-z\s]*)-----END MNEMONIC PHRASE-----/mi;
var MNEMONIC_MATCH_REGEX_LEGACY = /^[a-z\s]*$/i;
var getRequiredEthChain = function (network) {
    if (network === types_1.Network.MainNet) {
        return 1;
    }
    return 3;
};
var getEncryptMessage = function (input) {
    return ("\n  !!! Attention !!! Please make sure you are connecting to https://app.dem.exchange, do not confirm decrypt if you're connecting to untrusted sites.\n  -----BEGIN MNEMONIC PHRASE-----\n  " + input + "\n  -----END MNEMONIC PHRASE-----\n  ").trim().replaceAll(/^\s+/gm, '');
};
/**
 * TODO: Add docs
 */
var MetaMask = /** @class */ (function () {
    function MetaMask(network) {
        this.network = network;
        this.metamaskAPI = null;
        this.provider = null;
        var providerUrl = config_1.NETWORK[network].ETH_URL;
        if (providerUrl) {
            this.provider = new ethers_1.ethers.providers.JsonRpcProvider(providerUrl);
        }
    }
    MetaMask.prototype.checkProvider = function () {
        if (!this.provider) {
            throw new Error("MetaMask login not supported for this network " + this.network);
        }
        return this.provider;
    };
    MetaMask.prototype.getConnectedAPI = function () {
        return __awaiter(this, void 0, void 0, function () {
            var metamaskAPI;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.metamaskAPI && this.metamaskAPI.isConnected()) {
                            return [2 /*return*/, this.metamaskAPI];
                        }
                        metamaskAPI = window.ethereum;
                        if (metamaskAPI === undefined) {
                            throw new Error('MetaMask not connected, please check that your extension is enabled');
                        }
                        if (metamaskAPI.isConnected()) {
                            return [2 /*return*/, metamaskAPI];
                        }
                        return [4 /*yield*/, metamaskAPI.request({ method: 'eth_requestAccounts' })];
                    case 1:
                        _a.sent();
                        this.metamaskAPI = metamaskAPI;
                        return [2 /*return*/, this.metamaskAPI];
                }
            });
        });
    };
    MetaMask.prototype.connect = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.getConnectedAPI()];
            });
        });
    };
    MetaMask.prototype.defaultAccount = function () {
        return __awaiter(this, void 0, void 0, function () {
            var metamaskAPI, defaultAccount;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getConnectedAPI()];
                    case 1:
                        metamaskAPI = _a.sent();
                        return [4 /*yield*/, metamaskAPI.request({ method: 'eth_requestAccounts' })];
                    case 2:
                        defaultAccount = (_a.sent())[0];
                        if (!defaultAccount) {
                            throw new Error('No default account on MetaMask, please create one first');
                        }
                        return [2 /*return*/, defaultAccount];
                }
            });
        });
    };
    MetaMask.prototype.getStoredMnemonicCipher = function (account) {
        return __awaiter(this, void 0, void 0, function () {
            var contractHash, provider, contract, cipherTextHex;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        contractHash = this.getContractHash();
                        provider = this.checkProvider();
                        contract = new ethers_1.ethers.Contract(contractHash, registry_contract_1.default.abi, provider);
                        return [4 /*yield*/, contract.map(account)];
                    case 1:
                        cipherTextHex = _a.sent();
                        if (!(cipherTextHex === null || cipherTextHex === void 0 ? void 0 : cipherTextHex.length) || cipherTextHex === '0x') {
                            // value would be '0x' if not initialized
                            return [2 /*return*/, undefined];
                        }
                        return [2 /*return*/, cipherTextHex];
                }
            });
        });
    };
    MetaMask.prototype.encryptMnemonic = function (mnemonic) {
        return __awaiter(this, void 0, void 0, function () {
            var metamaskAPI, defaultAccount, publicKey, messageToEncrypt, cipher, version, nonce, ephemPublicKey, ciphertext, encryptedMnemonic;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getConnectedAPI()];
                    case 1:
                        metamaskAPI = _a.sent();
                        return [4 /*yield*/, this.defaultAccount()];
                    case 2:
                        defaultAccount = _a.sent();
                        return [4 /*yield*/, metamaskAPI.request({
                                method: 'eth_getEncryptionPublicKey',
                                params: [defaultAccount],
                            })];
                    case 3:
                        publicKey = _a.sent();
                        messageToEncrypt = getEncryptMessage(mnemonic);
                        cipher = ethSignUtils.encrypt(publicKey, {
                            data: messageToEncrypt,
                        }, ENCRYPTION_VERSION);
                        version = cipher.version, nonce = cipher.nonce, ephemPublicKey = cipher.ephemPublicKey, ciphertext = cipher.ciphertext;
                        encryptedMnemonic = ethers_1.ethers.utils.toUtf8Bytes([
                            version,
                            nonce,
                            ephemPublicKey,
                            ciphertext,
                        ].join('.'));
                        return [2 /*return*/, Buffer.from(encryptedMnemonic).toString('hex')];
                }
            });
        });
    };
    MetaMask.prototype.storeMnemonic = function (encryptedMnemonic) {
        return __awaiter(this, void 0, void 0, function () {
            var metamaskAPI, defaultAccount, storedMnemonicCipher, contractHash, provider, contract, dataBytes, unsignedTx, txHash;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getConnectedAPI()];
                    case 1:
                        metamaskAPI = _a.sent();
                        return [4 /*yield*/, this.defaultAccount()];
                    case 2:
                        defaultAccount = _a.sent();
                        return [4 /*yield*/, this.getStoredMnemonicCipher(defaultAccount)];
                    case 3:
                        storedMnemonicCipher = _a.sent();
                        if (storedMnemonicCipher) {
                            throw new Error('Cannot store key on registry - key already exists for ETH account');
                        }
                        contractHash = this.getContractHash();
                        provider = this.checkProvider();
                        contract = new ethers_1.ethers.Contract(contractHash, registry_contract_1.default.abi, provider);
                        dataBytes = Buffer.from(encryptedMnemonic, 'hex');
                        return [4 /*yield*/, contract.populateTransaction.Store(dataBytes)];
                    case 4:
                        unsignedTx = _a.sent();
                        return [4 /*yield*/, metamaskAPI.request({
                                method: 'eth_sendTransaction',
                                params: [__assign(__assign({}, unsignedTx), { from: defaultAccount })],
                            })];
                    case 5:
                        txHash = _a.sent();
                        return [2 /*return*/, txHash];
                }
            });
        });
    };
    MetaMask.prototype.login = function () {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var metamaskAPI, defaultAccount, cipherTextHex, chainIdHex, chainId, requiredChainId, requiredNetworkName, cipherText, _c, version, nonce, ephemPublicKey, ciphertext, cipher, decryptedCipherText, match;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0: return [4 /*yield*/, this.getConnectedAPI()];
                    case 1:
                        metamaskAPI = _d.sent();
                        return [4 /*yield*/, this.defaultAccount()];
                    case 2:
                        defaultAccount = _d.sent();
                        return [4 /*yield*/, this.getStoredMnemonicCipher(defaultAccount)];
                    case 3:
                        cipherTextHex = _d.sent();
                        return [4 /*yield*/, metamaskAPI.request({ method: 'eth_chainId' })];
                    case 4:
                        chainIdHex = _d.sent();
                        chainId = parseInt(chainIdHex, 16);
                        requiredChainId = getRequiredEthChain(this.network);
                        if (chainId !== requiredChainId) {
                            requiredNetworkName = ETH_CHAIN_NAMES[requiredChainId] || ETH_CHAIN_NAMES[3];
                            throw new Error("MetaMask not connected to correct network, please use " + requiredNetworkName);
                        }
                        if (!cipherTextHex || !cipherTextHex.length) {
                            return [2 /*return*/, null];
                        }
                        cipherText = ethers_1.ethers.utils.toUtf8String(cipherTextHex);
                        _c = cipherText.split('.'), version = _c[0], nonce = _c[1], ephemPublicKey = _c[2], ciphertext = _c[3];
                        cipher = {
                            version: version,
                            nonce: nonce,
                            ephemPublicKey: ephemPublicKey,
                            ciphertext: ciphertext,
                        };
                        return [4 /*yield*/, metamaskAPI.request({
                                method: 'eth_decrypt',
                                params: [JSON.stringify(cipher), defaultAccount],
                            })];
                    case 5:
                        decryptedCipherText = (_a = (_d.sent())) === null || _a === void 0 ? void 0 : _a.trim();
                        // legacy encrypted mnemonic doesnt include warning message.
                        if (decryptedCipherText.match(MNEMONIC_MATCH_REGEX_LEGACY)) {
                            return [2 /*return*/, decryptedCipherText];
                        }
                        match = decryptedCipherText.match(MNEMONIC_MATCH_REGEX);
                        // invalid cipher
                        if (!match) {
                            console.error('invalid account info retrieved from contract');
                            console.error(decryptedCipherText);
                            throw new Error('Retrieved invalid account on blockchain, please check console for more information.');
                        }
                        return [2 /*return*/, (_b = match[1]) === null || _b === void 0 ? void 0 : _b.trim()];
                }
            });
        });
    };
    MetaMask.prototype.getContractHash = function () {
        var contractHash = CONTRACT_HASH[this.network];
        if (!contractHash) {
            throw new Error("MetaMask login is not supported on " + this.network);
        }
        return contractHash;
    };
    return MetaMask;
}());
exports.MetaMask = MetaMask;
exports.default = MetaMask;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWV0YU1hc2suanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvbGliL3Byb3ZpZGVycy9tZXRhbWFzay9NZXRhTWFzay50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEseURBQTRDO0FBQzVDLDBFQUFrRDtBQUNsRCxpQ0FBK0I7QUFDL0IscUNBQXFDO0FBQ3JDLHVDQUFzQztBQUV0QyxJQUFNLGFBQWE7SUFDakIscURBQXFEO0lBQ3JELEdBQUMsZUFBTyxDQUFDLE9BQU8sSUFBRyw0Q0FBNEM7SUFDL0QsR0FBQyxlQUFPLENBQUMsTUFBTSxJQUFHLDRDQUE0QztJQUM5RCxHQUFDLGVBQU8sQ0FBQyxTQUFTLElBQUcsNENBQTRDO0lBRWpFLEdBQUMsZUFBTyxDQUFDLE9BQU8sSUFBRyw0Q0FBNEM7T0FDaEUsQ0FBQTtBQUVELElBQU0sZUFBZSxHQUFHO0lBQ3RCLENBQUMsRUFBRSxTQUFTO0lBQ1osQ0FBQyxFQUFFLFNBQVM7Q0FDSixDQUFBO0FBRVYsSUFBTSxrQkFBa0IsR0FBRywwQkFBMEIsQ0FBQTtBQUVyRCxJQUFNLG9CQUFvQixHQUFHLDBFQUEwRSxDQUFBO0FBQ3ZHLElBQU0sMkJBQTJCLEdBQUcsYUFBYSxDQUFBO0FBRWpELElBQU0sbUJBQW1CLEdBQUcsVUFBQyxPQUFnQjtJQUMzQyxJQUFJLE9BQU8sS0FBSyxlQUFPLENBQUMsT0FBTyxFQUFFO1FBQy9CLE9BQU8sQ0FBQyxDQUFBO0tBQ1Q7SUFFRCxPQUFPLENBQUMsQ0FBQTtBQUNWLENBQUMsQ0FBQTtBQUVELElBQU0saUJBQWlCLEdBQUcsVUFBQyxLQUFhO0lBQ3RDLE9BQU8sQ0FBQSxrTUFHTCxLQUFLLDBDQUVOLENBQUEsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQyxD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