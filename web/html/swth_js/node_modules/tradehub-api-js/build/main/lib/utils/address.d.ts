/// <reference types="node" />
import { Bech32Type } from '../types';
import { Network } from '../config';
/**
 * Convenience function to coalesce a string/buffer into a buffer
 *
 * @param stringOrBuffer a string or buffer type
 * @param encoding BufferEncoding from Buffer
 * @param force option to return an empty buffer regardless of input
 */
export declare const stringOrBufferToBuffer: (stringOrBuffer?: string | Buffer, encoding?: BufferEncoding, force?: boolean) => Buffer | null;
export declare const randomMnemonic: () => string;
export declare const wifEncodePrivateKey: (privateKey: string | Buffer, iter?: number) => any;
export interface AddressOptions {
}
export interface AddressBuilder<T extends AddressOptions> {
    /**
     * BIP44 coin type
     * used in `m/44'/${coinType}'/0'/0/0`
     */
    coinType(): number;
    /**
     * derives address
     *
     * @param publicKey accepts both encoded/compressed or unencoded/uncompressed public key
     */
    publicKeyToScriptHash(publicKey: string | Buffer): string;
    publicKeyToAddress(publicKey: string | Buffer, opts?: T): string;
    generateAddress(privateKey: string, account?: number, opts?: T): string;
    mnemonicToPrivateKey(mnemonic: string, account?: number, opts?: T): Buffer;
    /**
     * Returns a 33-byte encoded/compressed public key, also known as the encoded public key
     *
     * @param unencodedPublicKey - 65-byte raw/unencoded public key
     */
    encodePublicKey(unencodedPublicKey: string | Buffer): Buffer;
}
export interface SWTHAddressOptions extends AddressOptions {
    network: Network;
    type: Bech32Type;
}
export declare const SWTHAddress: AddressBuilder<SWTHAddressOptions>;
export declare const NEOAddress: AddressBuilder<AddressOptions>;
