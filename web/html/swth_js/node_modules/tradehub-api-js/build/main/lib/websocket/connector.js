"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WSConnector = exports.WSConnectorTypes = exports.WSChannel = void 0;
var ws_1 = __importDefault(require("ws"));
var channel_1 = require("./channel");
var WSConnectorTypes = __importStar(require("./types"));
exports.WSConnectorTypes = WSConnectorTypes;
var utils_1 = require("../utils");
// delay between pings.
// see WSConnector.intervalHeartbeat
var DEFAULT_INTERVAL_HEARTBEAT = 3000;
// 2x DEFAULT_INTERVAL_HEARTBEAT to allow for missing
// one heartbeat without triggering disconnect.
// see WSConnector.timeoutHeartbeat
var DEFAULT_TIMEOUT_HEARTBEAT = 6100;
// see WSConnector.timeoutConnect
var DEFAULT_TIMEOUT_CONNECT = 2000;
exports.WSChannel = WSConnectorTypes.WSChannel;
/**
 * WSConnector is a wrapper class to manage websocket connections with the server. It makes use of
 * WebSocket instances to connect to the server.
 *
 * Provides a synchronised way of executing requests on websocket @see {WSConnector.request}.
 *
 * Multiple subscriptions to the same channel is not supported at the moment, but would be trival
 * to implement.
 *
 * @example
 * (async () => {
 *   const wsConnector = new WSConnector({
 *     endpoint: WS_ENDPOINT,
 *   });
 *
 *   // run connect before executing any request/subscription
 *   await wsConnector.connect();
 *
 *   // request for data
 *   const result: WSResult<RecentTradesBody> = await wsConnector.request<RecentTradesBody>("get_recent_trades", {
 *      market: "swth_eth",
 *   });
 *
 *   // subscribe to new channel
 *   await wsConnector.subscribe({ channel: WSChannel.market_stats }, (result: WSResult<MarketStats>) => {
 *     console.log("received market stats", result);
 *   });
 *
 *   // unsubscribe
 *   await wsConnector.unsubscribe({ channel: WSChannel.market_stats });
 *
 *   // clean up
 *   await wsConnector.disconnect();
 * })();
 */
var WSConnector = /** @class */ (function () {
    /**
     * Initialises an instance of WSConnector with the specified options
     * @param {WSConnectorOptions} options - options to configure the WSConnector instance
     */
    function WSConnector(options) {
        // websocket instance
        this.websocket = null;
        // used to tracking websocket messages, increment by 1 every request
        this.requestIdCounter = 0;
        // true if connection initiated, even if connection is not established
        // will cause reconnect attempts if true.
        this.shouldConnect = false;
        // true only if connection is established and ready to use
        this.connected = false;
        // promise abstraction handler for WSConnector.connect
        this.connectPromiseHandler = null;
        // promise abstraction handlers store for WSConnector.request
        this.requestHandlers = {};
        // channel subscription handlers
        this.channelHandlers = {};
        // used for track ws message sequence, for some cases a out of sequence
        // message is invalid and request have to be resent.
        this.sequenceNumberCache = {};
        var endpoint = options.endpoint, _a = options.debugMode, debugMode = _a === void 0 ? false : _a, _b = options.timeoutConnect, timeoutConnect = _b === void 0 ? DEFAULT_TIMEOUT_CONNECT : _b, _c = options.intervalHeartbeat, intervalHeartbeat = _c === void 0 ? DEFAULT_INTERVAL_HEARTBEAT : _c, _d = options.timeoutHeartbeat, timeoutHeartbeat = _d === void 0 ? DEFAULT_TIMEOUT_HEARTBEAT : _d, _e = options.disableHeartbeat, disableHeartbeat = _e === void 0 ? false : _e, onStatusChange = options.onStatusChange;
        this.endpoint = endpoint;
        this.debugMode = debugMode;
        this.timeoutConnect = timeoutConnect;
        this.intervalHeartbeat = intervalHeartbeat;
        this.timeoutHeartbeat = timeoutHeartbeat;
        this.disableHeartbeat = disableHeartbeat;
        this.statusChangeListener = onStatusChange;
    }
    /**
     * Starts a connection to the server via a WebSocket instance
     * rejects the promise if connection cannot be established within WSConnector.timeoutConnect
     * milliseconds.
     *
     * @see WSConnector documentation for usage example
     */
    WSConnector.prototype.connect = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                if (this.shouldConnect) {
                    // resolve promise immediately if already connecting
                    return [2 /*return*/, Promise.resolve()];
                }
                this.shouldConnect = true;
                this.connectWebSocket();
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        _this.connectPromiseHandler = { resolve: resolve, reject: reject };
                    })];
            });
        });
    };
    /**
     * Disconnects the WebSocket connection with endpoint, releases resources and reverse states.
     * It is safe to call WSConnector.connect() again once WSConnector.disconnect() is called.
     *
     * @see WSConnector documentation for usage example
     */
    WSConnector.prototype.disconnect = function () {
        this.shouldConnect = false;
        this.disconnectWebsocket();
    };
    /**
     * Subscribes to the channels specified with the websocket. Sends a subscription data frame with
     * channel ID to WebSocket server.
     * @param {WSConnectorTypes.WsSubscriptionParams | WSConnectorTypes.WsSubscriptionParams[]} params a list of parameters specifying the channels to connect to
     * @param {WSSubscriber} handler an event handler that subscribes to the websocket channels
     *
     * @see WSConnector documentation for usage example
     */
    WSConnector.prototype.subscribe = function (params, handler) {
        var channels = [];
        if (!Array.isArray(params)) {
            params = [params]; // eslint-disable-line no-param-reassign
        }
        for (var _i = 0, _a = params; _i < _a.length; _i++) {
            var param = _a[_i];
            var channelId = channel_1.generateChannelId(param);
            var shouldSubscribe = this.channelHandlers[channelId] === undefined;
            this.channelHandlers[channelId] = handler;
            if (shouldSubscribe) {
                channels.push(channelId);
            }
        }
        this.send('subscribe', { channels: channels });
    };
    /**
     * Unsubscribes to the websocket channels indicated in the params, by broadcasting an unsubscribe
     * message to these channels.
     * @param {WSConnectorTypes.WsSubscriptionParams | WSConnectorTypes.WsSubscriptionParams[]} params - channel(s) to unsubcribe to
     *
     * @see WSConnector documentation for usage example
     */
    WSConnector.prototype.unsubscribe = function (params) {
        if (!Array.isArray(params)) {
            params = [params]; // eslint-disable-line no-param-reassign
        }
        var channelIds = [];
        for (var _i = 0, params_1 = params; _i < params_1.length; _i++) {
            var param = params_1[_i];
            var channelId = channel_1.generateChannelId(param);
            delete this.channelHandlers[channelId];
        }
        this.send('unsubscribe', {
            channels: channelIds,
        });
    };
    /**
     * Sends a message to the websocket channels.
     * @param {string} method - the type of message to send to the websocket channels. Available
     * options: subscribe, unsubscribe, get_recent_trades, get_candlesticks, get_open_orders,
     * get_account_trades, get_market_stats, get_leverages, get_open_positions, get_closed_positions
     * @param {any} params - An object containing parameters based on the specified method
     */
    WSConnector.prototype.send = function (method, params) {
        this.sendMessage(JSON.stringify({
            id: "g" + ++this.requestIdCounter,
            method: method,
            params: params,
        }));
    };
    /**
     * Requests data from the server endpoint
     * @param {string} method - the type of message to send to the websocket channels. Available
     * options: subscribe, unsubscribe, get_recent_trades, get_candlesticks, get_open_orders,
     * get_account_trades, get_market_stats, get_leverages, get_open_positions, get_closed_positions
     * @param {any} params - parameters based on the specified method
     *
     * @returns {Promise<WSResult<T>>} - a Promise resolving to the response from the endpoint
     *
     * @see WSConnector documentation for usage example
     */
    WSConnector.prototype.request = function (method, params) {
        return __awaiter(this, void 0, void 0, function () {
            var requestId;
            var _this = this;
            return __generator(this, function (_a) {
                requestId = "r" + ++this.requestIdCounter;
                this.sendMessage(JSON.stringify({
                    id: requestId,
                    method: method,
                    params: params,
                }));
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        _this.requestHandlers[requestId] = { requestId: requestId, resolve: resolve, reject: reject };
                    })];
            });
        });
    };
    /**
     * Sends a message to the web socket
     * @param {string | Buffer} data - the message sent to the web socket
     */
    WSConnector.prototype.sendMessage = function (data) {
        var socket = this.getSocket();
        this.debugLog('WSConnector.sendMessage', data);
        socket === null || socket === void 0 ? void 0 : socket.send(data);
    };
    /**
     * An event handler that is called when a connection is started with the WebSocket instance.
     * @param {Event} ev - the event that is called with
     */
    WSConnector.prototype.onOpen = function (ev) {
        var _a;
        this.debugLog('WSConnector.onOpen', ev);
        // clear timeout for killing connect attempts
        clearTimeout(this.timeoutConnect);
        this.connected = true;
        (_a = this.connectPromiseHandler) === null || _a === void 0 ? void 0 : _a.resolve();
        this.connectPromiseHandler = null;
        this.updateConnectStatus();
        this.startHeartbeat();
    };
    /**
     * An event handler that is called when a MessageEvent is emitted from the server
     * @param {MessageEvent} ev - the MessageEvent that is emitted from the server
     */
    WSConnector.prototype.onMessage = function (ev) {
        var _a;
        this.debugLog('WSConnector.onMessage', ev);
        if (ev.data === 'pong') {
            this.restartHeartbeatTimeout();
            return;
        }
        var message = this.parseWsMessage(ev);
        if (!message.requestId && message.channel) {
            var channelHandler = this.channelHandlers[message.channel];
            if (!channelHandler) {
                this.debugLog("handler not found for channel: " + message.channel);
                this.unsubscribe({ channel: message.channel });
                return;
            }
            channelHandler(message.result);
            return;
        }
        if (!((_a = message.requestId) === null || _a === void 0 ? void 0 : _a.startsWith('r'))) {
            return;
        }
        var handler = this.requestHandlers[message.requestId];
        if (!handler) {
            this.debugLog("handler not found for request: " + message.requestId);
            return;
        }
        if (message.error) {
            handler.reject(message.error);
        }
        else {
            handler.resolve(message.result);
        }
        delete this.requestHandlers[message.requestId];
    };
    /**
     * An event listener that is called when an error occurs on the WebSocket connection
     * @param {Event} ev - the error event occurring on the WebSocket connection
     */
    WSConnector.prototype.onError = function (ev) {
        this.debugLog('WSConnector.onError', ev);
        var handlers = Object.values(this.requestHandlers);
        console.error(ev);
        var error = new Error('WebSocket error occurred');
        for (var _i = 0, handlers_1 = handlers; _i < handlers_1.length; _i++) {
            var handler = handlers_1[_i];
            handler.reject(error);
            if (handler.requestId) {
                delete this.requestHandlers[handler.requestId];
            }
        }
    };
    /**
     * An event handler that is triggered when the WebSocket connection is closed.
     * @param {Event} ev - the event called with this event handler.
     */
    WSConnector.prototype.onClose = function (ev) {
        this.debugLog('WSConnector.onClose', ev);
        this.disconnectWebsocket();
    };
    /**
     * An accessor to the WebSocket instance in this WSConnector instance
     */
    WSConnector.prototype.getSocket = function () {
        if (!this.connected) {
            throw new Error('WebSocket not connected');
        }
        return this.websocket;
    };
    /**
     * Updates the connection status of the WebSocket instance
     */
    WSConnector.prototype.updateConnectStatus = function () {
        var _a;
        try {
            (_a = this.statusChangeListener) === null || _a === void 0 ? void 0 : _a.call(this, this.connected);
        }
        catch (error) {
            console.error(error);
        }
    };
    /**
     * Sends ping messages to the websocket to indicate to the server that the WebSocket connection with the server is still alive.
     */
    WSConnector.prototype.sendHeartbeat = function () {
        var _a;
        (_a = this.websocket) === null || _a === void 0 ? void 0 : _a.send('ping');
    };
    /**
     * Resets the heartbeat timeout. (timeout: after a specified amount of time, if there are no heartbeats detected from the server, the connection with the server is considered to be lost and the WebSocket connection will be closed)
     */
    WSConnector.prototype.restartHeartbeatTimeout = function () {
        clearTimeout(this.heartbeatTimeout);
        if (this.disableHeartbeat || this.timeoutHeartbeat <= 0) {
            // configured to disable heartbeat checks
            return;
        }
        this.heartbeatTimeout = setTimeout(this.onHeartbeatTimeout.bind(this), this.timeoutHeartbeat);
    };
    /**
     * Disconnects the websocket connection when there is no heartbeat detected for more than the time specified in {@link WSConnector#timeoutHeartbeat}
     */
    WSConnector.prototype.onHeartbeatTimeout = function () {
        this.debugLog('heartbeat timed out');
        console.warn('ws heartbeat missed, killing zombie connection');
        this.disconnect();
    };
    /**
     * Starts sending heartbeats to the server in regular intervals
     */
    WSConnector.prototype.startHeartbeat = function () {
        // call receive heartbeat to start timeout
        this.restartHeartbeatTimeout();
        if (this.disableHeartbeat || this.intervalHeartbeat <= 0) {
            // configured to disable heartbeat checks
            return;
        }
        this.heartbeatInterval = setInterval(this.sendHeartbeat.bind(this), this.intervalHeartbeat);
    };
    /**
     * Parses messages sent from the server via the WebSocket connection
     * @param {MessageEvent} ev - the MessageEvent emitted from the server
     * @returns {WSMessage<T>} - the parsed message
     */
    WSConnector.prototype.parseWsMessage = function (ev) {
        try {
            var _a = JSON.parse(ev.data), id = _a.id, sequenceNumber = _a.sequence_number, error = _a.error, channel = _a.channel, rest = __rest(_a, ["id", "sequence_number", "error", "channel"]);
            var outOfSequence = sequenceNumber < this.sequenceNumberCache[channel];
            if (!outOfSequence) {
                this.sequenceNumberCache[channel] = sequenceNumber;
            }
            return {
                requestId: id,
                channel: channel,
                sequenceNumber: sequenceNumber,
                error: error,
                result: {
                    requestId: id,
                    channel: channel,
                    timestamp: new Date(),
                    outOfSequence: outOfSequence,
                    data: rest,
                },
            };
        }
        catch (error) {
            console.error(error);
            throw error;
        }
    };
    /**
     * Rejects the WebSocket connection attempt when an error is encountered
     * @param {Error} error - the error causing the failure to connect with the websocket
     */
    WSConnector.prototype.rejectConnect = function (error) {
        var _a;
        clearTimeout(this.initFailureTimeout);
        (_a = this.connectPromiseHandler) === null || _a === void 0 ? void 0 : _a.reject(error);
        this.connectPromiseHandler = null;
    };
    /**
     * Disconnects the connection with the websocket
     */
    WSConnector.prototype.disconnectWebsocket = function () {
        var _a;
        try {
            (_a = this.websocket) === null || _a === void 0 ? void 0 : _a.close();
        }
        catch (e) {
            // ignore error on disconnect
        }
        finally {
            clearInterval(this.heartbeatInterval);
            clearTimeout(this.heartbeatTimeout);
            this.sequenceNumberCache = {};
            this.websocket = null;
            if (this.connected) {
                this.connected = false;
                this.updateConnectStatus();
            }
        }
    };
    /**
     * Initialises a new WebSocket instance with the specified endpoint.
     */
    WSConnector.prototype.connectWebSocket = function () {
        var _this = this;
        this.disconnect();
        try {
            if (typeof WebSocket !== 'undefined') {
                // this works on browsers js vm
                var websocket = new WebSocket(this.endpoint);
                websocket.onopen = this.onOpen.bind(this);
                websocket.onclose = this.onClose.bind(this);
                websocket.onerror = this.onError.bind(this);
                websocket.onmessage = this.onMessage.bind(this);
                this.websocket = websocket;
            }
            else {
                // and this works on nodejs vm
                var websocket = new ws_1.default(this.endpoint);
                websocket.on('open', this.onOpen.bind(this));
                websocket.on('close', this.onClose.bind(this));
                websocket.on('error', this.onError.bind(this));
                websocket.on('message', function (data) { return _this.onMessage({ data: data }); });
                this.websocket = websocket;
            }
            this.requestHandlers = {};
            // set timeout to kill websocket instantiation attempt
            // because error for constructor cannot be caught
            // i.e. new WebSocket(…)
            // https://stackoverflow.com/questions/22919638
            this.initFailureTimeout = setTimeout(function () {
                _this.rejectConnect(new Error('websocket connect time out'));
            }, this.timeoutConnect);
        }
        catch (error) {
            console.error(error);
            this.rejectConnect(error);
        }
    };
    /**
     * A helper message to log methods when they are called
     * WSConnector#debugMode must be set to true to turn on logging.
     * @param {any[]} args - items to be logged
     */
    WSConnector.prototype.debugLog = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (!this.debugMode)
            return;
        utils_1.logger.apply(void 0, args);
    };
    WSConnector.generateChannelId = channel_1.generateChannelId;
    WSConnector.parseChannelId = channel_1.parseChannelId;
    return WSConnector;
}());
exports.WSConnector = WSConnector;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29ubmVjdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2xpYi93ZWJzb2NrZXQvY29ubmVjdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDBDQUE4QjtBQUU5QixxQ0FBNkQ7QUFDN0Qsd0RBQTJDO0FBaUJsQyw0Q0FBZ0I7QUFmekIsa0NBQWlDO0FBRWpDLHVCQUF1QjtBQUN2QixvQ0FBb0M7QUFDcEMsSUFBTSwwQkFBMEIsR0FBRyxJQUFJLENBQUE7QUFFdkMscURBQXFEO0FBQ3JELCtDQUErQztBQUMvQyxtQ0FBbUM7QUFDbkMsSUFBTSx5QkFBeUIsR0FBRyxJQUFJLENBQUE7QUFFdEMsaUNBQWlDO0FBQ2pDLElBQU0sdUJBQXVCLEdBQUcsSUFBSSxDQUFBO0FBRXJCLFFBQUEsU0FBUyxHQUFLLGdCQUFnQixXQUFBO0FBOEQ3Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQWtDRztBQUNIO0lBdUVFOzs7T0FHRztJQUNILHFCQUNFLE9BQTJCO1FBbEQ3QixxQkFBcUI7UUFDckIsY0FBUyxHQUFxQixJQUFJLENBQUE7UUFFbEMsb0VBQW9FO1FBQ3BFLHFCQUFnQixHQUFXLENBQUMsQ0FBQTtRQUU1QixzRUFBc0U7UUFDdEUseUNBQXlDO1FBQ3pDLGtCQUFhLEdBQVksS0FBSyxDQUFBO1FBRTlCLDBEQUEwRDtRQUMxRCxjQUFTLEdBQVksS0FBSyxDQUFBO1FBSzFCLHNEQUFzRDtRQUN0RCwwQkFBcUIsR0FBMEIsSUFBSSxDQUFBO1FBRW5ELDZEQUE2RDtRQUM3RCxvQkFBZSxHQUF3QixFQUFFLENBQUE7UUFFekMsZ0NBQWdDO1FBQ2hDLG9CQUFlLEdBQXVCLEVBQUUsQ0FBQTtRQUV4Qyx1RUFBdUU7UUFDdkUsb0RBQW9EO1FBQ3BELHdCQUFtQixHQUVm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