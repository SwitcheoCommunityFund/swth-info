import { ethers } from 'ethers';
import { Network } from '../config';
import { StdSignDoc } from '../containers';
import { PrivKeySecp256k1, PubKeySecp256k1 } from '../utils/wallet';
import { ConcreteMsg } from '../containers/Transaction';
import { HDWallet } from '../utils/hdwallet';
import CosmosLedger from '@lunie/cosmos-ledger';
import { FeeResult } from '../models';
import { TokenList } from '../models/balances/NeoBalances';
export declare type SignerType = 'ledger' | 'mnemonic' | 'privateKey' | 'nosign';
export declare type OnRequestSignCallback = (signDoc: StdSignDoc) => void;
export declare type OnSignCompleteCallback = (signature: string) => void;
export interface SignMessageOptions {
    memo?: string;
    sequence?: string;
}
export interface GasFees {
    [msgType: string]: string;
}
export interface WalletConstructorParams {
    accountNumber?: string;
    network: Network;
    useSequenceCounter?: boolean;
    broadcastQueueIntervalTime?: number;
    pubKey?: Array<Number>;
    pubKeyBech32?: string;
    mnemonic?: string;
    privateKey?: string;
    gas?: string;
    signerType?: SignerType;
    ledger?: CosmosLedger;
    fees?: GasFees;
    onRequestSign?: OnRequestSignCallback;
    onSignComplete?: OnSignCompleteCallback;
}
export interface InitParams {
    accountNumber?: string;
    fees?: GasFees;
}
export interface BroadcastQueueItem {
    id: string;
    concreteMsgs: ConcreteMsg[];
    options: any;
}
export interface BroadcastResults {
    [id: string]: any;
}
export declare class WalletClient {
    static connectMnemonic(mnemonic: string, net?: string): Promise<WalletClient>;
    static connectPrivateKey(privateKey: string, net?: string): Promise<WalletClient>;
    static connectLedger(cosmosLedger: CosmosLedger, net: string, onRequestSign: OnRequestSignCallback, onSignComplete: OnSignCompleteCallback): Promise<WalletClient>;
    static connectPublicKey(pubKeyBech32: string, net?: string): Promise<WalletClient>;
    readonly mnemonic?: string;
    readonly hdWallet: HDWallet;
    readonly privKey: PrivKeySecp256k1;
    readonly address: Uint8Array;
    readonly addressHex: string;
    readonly pubKeySecp256k1: PubKeySecp256k1;
    readonly pubKeyBase64: string;
    readonly pubKeyBech32: string;
    readonly validatorBech32: string;
    readonly consensusBech32: string;
    readonly gas: string;
    readonly signerType: SignerType;
    readonly ledger?: CosmosLedger;
    readonly network: Network;
    readonly feeMultiplier: ethers.BigNumber;
    fees: GasFees;
    accountNumber: string;
    broadcastMode: string;
    depositAddresses: {
        [key: string]: string;
    };
    onRequestSign?: OnRequestSignCallback;
    onSignComplete?: OnSignCompleteCallback;
    private useSequenceCounter;
    private sequenceCounter?;
    private broadcastQueueIntervalTime;
    private broadcastQueueIntervalId;
    private broadcastQueue;
    private broadcastResults;
    private isBroadcastQueuePaused;
    private neoDepositsIntervalId;
    constructor(params: WalletConstructorParams);
    disconnect(): void;
    sign(message: any): {
        pub_key: {
            type: string;
            value: string;
        };
        signature: string;
    };
    initialize(params: InitParams): void;
    broadcast(body: any): Promise<any>;
    getAccount(): Promise<any>;
    getWalletBalance(): Promise<any>;
    getTransfers(): Promise<any>;
    watchDepositAddresses(whitelistDenoms?: string[]): Promise<void>;
    watchNeoDepositAddress(whitelistDenoms?: string[]): Promise<void>;
    sendNeoDeposits(address: any, whitelistDenoms?: string[]): Promise<void>;
    getTargetProxyHash(token: any): any;
    getFeeInfo(denom: string): Promise<FeeResult>;
    sendNeoDeposit(token: any, feeAmountInput: any, _privateKey?: any): Promise<false | import("@cityofzion/neon-api/lib/funcs/types").DoInvokeConfig>;
    watchEthDepositAddress(whitelistDenoms?: string[]): Promise<void>;
    sendEthDeposits(address: any, whitelistDenoms?: string[]): Promise<void>;
    isEthContract(address: any): Promise<boolean>;
    getDepositFeeAmount(token: any, depositAddress: any): Promise<ethers.BigNumber>;
    getWithdrawalFeeAmount(token: any): Promise<ethers.BigNumber>;
    getMinDepositAmount(token: any, depositAddress: any): Promise<ethers.BigNumber>;
    getMinWithdrawalAmount(token: any): Promise<ethers.BigNumber>;
    sendEthDeposit(token: any, depositAddress: any): Promise<import("node-fetch").Response | "insufficient balance">;
    getDepositAddress(blockchain: string): Promise<string>;
    getTokens(): Promise<any>;
    getNeoDepositAddress(): Promise<string>;
    getEthDepositAddress(): Promise<any>;
    getEthProvider(): ethers.providers.BaseProvider;
    getEthExternalBalances(address: string, whitelistDenoms?: string[]): Promise<any>;
    getNeoRpcUrl(): Promise<string>;
    getRandomNeoRpcUrl(): string;
    private parseHexNum;
    getNeoExternalBalances(address: string, url: string, whitelistDenoms?: string[]): Promise<TokenList>;
    signMessage(msgs: ConcreteMsg[], options?: any): Promise<{
        pub_key: {
            type: string;
            value: string;
        };
        signature: any;
    }>;
    signAndBroadcast(msgs: object[], types: string[], options: any): Promise<any>;
    seqSignAndBroadcast(msgs: object[], types: string[], options: any): Promise<any>;
    private processBroadcastQueue;
    private constructConcreteMsgs;
}
export declare function getPrivKeyFromMnemonic(mnemonic: any): string;
export declare function newAccount(net: string): {
    mnemonic: string;
    privateKey: string;
    pubKeyBech32: string;
};
export declare function accountFromMnemonic(mnemonic: any, net: string): {
    mnemonic: any;
    privateKey: string;
    pubKeyBech32: string;
};
