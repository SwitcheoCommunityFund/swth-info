var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
import * as bip32 from 'bip32';
import * as bip39 from 'bip39';
import fetch from 'node-fetch';
import { BigNumber } from 'bignumber.js';
import Dagger from '@maticnetwork/eth-dagger';
import { ethers } from 'ethers';
import { CONFIG, getBech32Prefix, getNetwork } from '../config';
import { Fee, StdSignDoc, Transaction } from '../containers';
import { marshalJSON, sortAndStringifyJSON } from '../utils/encoder';
import { Address, getPath, PrivKeySecp256k1, PubKeySecp256k1 } from '../utils/wallet';
import { HDWallet } from '../utils/hdwallet';
import BALANCE_READER_ABI from '../eth/abis/balanceReader.json';
import LOCK_PROXY_ABI from '../eth/abis/lockProxy.json';
import { Blockchain, ETH_WALLET_BYTECODE } from '../constants';
import Neon, { api, u } from '@cityofzion/neon-js';
import stripHexPrefix from 'strip-hex-prefix';
import { wallet as neonWallet, rpc as neonRPC, sc as neonScript, u as neonUtils } from '@cityofzion/neon-core';
import { chunk } from 'lodash';
var WalletClient = /** @class */ (function () {
    function WalletClient(params) {
        var _this = this;
        var mnemonic = params.mnemonic, pubKeyBech32 = params.pubKeyBech32, pubKey = params.pubKey, accountNumber = params.accountNumber, network = params.network, _a = params.broadcastQueueIntervalTime, broadcastQueueIntervalTime = _a === void 0 ? 100 : _a, _b = params.useSequenceCounter, useSequenceCounter = _b === void 0 ? true : _b, privateKey = params.privateKey, signerType = params.signerType, ledger = params.ledger, _c = params.gas, gas = _c === void 0 ? CONFIG.DEFAULT_GAS : _c, onRequestSign = params.onRequestSign, onSignComplete = params.onSignComplete, fees = params.fees;
        if (!mnemonic && signerType === 'mnemonic') {
            throw new Error('Signer Type is mnemonic but mnemonic is not passed in');
        }
        if (!privateKey && signerType === 'privateKey') {
            throw new Error('Signer Type is privateKey but privateKey is not passed in');
        }
        var address;
        if (mnemonic) {
            var privateKey_1 = getPrivKeyFromMnemonic(mnemonic);
            var privKey = new PrivKeySecp256k1(Buffer.from(privateKey_1, 'hex'));
            this.mnemonic = mnemonic;
            this.hdWallet = HDWallet.getWallet(mnemonic);
            this.privKey = privKey;
            this.pubKeySecp256k1 = this.privKey.toPubKey();
            address = this.pubKeySecp256k1.toAddress();
            this.pubKeyBase64 = this.pubKeySecp256k1.pubKey.toString('base64');
        }
        else if (privateKey) {
            this.privKey = new PrivKeySecp256k1(Buffer.from(privateKey, 'hex'));
            this.pubKeySecp256k1 = this.privKey.toPubKey();
            address = this.pubKeySecp256k1.toAddress();
            this.pubKeyBase64 = this.pubKeySecp256k1.pubKey.toString('base64');
        }
        else if (signerType === 'nosign') {
            address = Address.fromBech32(getBech32Prefix(network, 'main'), pubKeyBech32);
        }
        else {
            this.pubKeySecp256k1 = new PubKeySecp256k1(Buffer.from(pubKey));
            this.pubKeyBase64 = this.pubKeySecp256k1.pubKey.toString('base64');
            address = Address.fromBech32(getBech32Prefix(network, 'main'), pubKeyBech32);
        }
        this.fees = fees;
        this.address = address.toBytes();
        this.addressHex = stripHexPrefix(ethers.utils.hexlify(this.address));
        this.pubKeyBech32 = address.toBech32(getBech32Prefix(network, 'main'));
        this.validatorBech32 = address.toBech32(getBech32Prefix(network, 'validator'));
        this.consensusBech32 = address.toBech32(getBech32Prefix(network, 'consensus'));
        this.signerType = signerType;
        this.gas = gas;
        this.accountNumber = accountNumber;
        this.network = network;
        this.depositAddresses = {};
        this.ledger = ledger;
        this.onRequestSign = onRequestSign;
        this.onSignComplete = onSignComplete;
        this.feeMultiplier = ethers.BigNumber.from(2);
        this.useSequenceCounter = useSequenceCounter;
        this.broadcastQueueIntervalTime = broadcastQueueIntervalTime;
        this.broadcastQueue = [];
        this.broadcastResults = {};
        this.broadcastQueueIntervalId = setInterval(function () {
            _this.processBroadcastQueue();
        }, this.broadcastQueueIntervalTime);
    }
    WalletClient.connectMnemonic = function (mnemonic, net) {
        return __awaiter(this, void 0, void 0, function () {
            var network;
            return __generator(this, function (_a) {
                network = getNetwork(net);
                return [2 /*return*/, new WalletClient({
                        mnemonic: mnemonic,
                        network: network,
                        signerType: 'mnemonic',
                    })];
            });
        });
    };
    WalletClient.connectPrivateKey = function (privateKey, net) {
        return __awaiter(this, void 0, void 0, function () {
            var network;
            return __generator(this, function (_a) {
                network = getNetwork(net);
                return [2 /*return*/, new WalletClient({
                        privateKey: privateKey,
                        network: network,
                        signerType: 'privateKey',
                    })];
            });
        });
    };
    WalletClient.connectLedger = function (cosmosLedger, net, onRequestSign, onSignComplete) {
        if (net === void 0) { net = 'TESTNET'; }
        return __awaiter(this, void 0, void 0, function () {
            var network, pubKeyBech32, pubKey;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        network = getNetwork(net);
                        return [4 /*yield*/, cosmosLedger.getCosmosAddress()];
                    case 1:
                        pubKeyBech32 = _a.sent();
                        return [4 /*yield*/, cosmosLedger.getPubKey()];
                    case 2:
                        pubKey = _a.sent();
                        return [2 /*return*/, new WalletClient({
                                ledger: cosmosLedger,
                                network: network,
                                pubKey: pubKey,
                                pubKeyBech32: pubKeyBech32,
                                signerType: 'ledger',
                                onRequestSign: onRequestSign,
                                onSignComplete: onSignComplete,
                            })];
                }
            });
        });
    };
    // for debug view
    WalletClient.connectPublicKey = function (pubKeyBech32, net) {
        return __awaiter(this, void 0, void 0, function () {
            var network;
            return __generator(this, function (_a) {
                network = getNetwork(net);
                return [2 /*return*/, new WalletClient({
                        network: network,
                        pubKeyBech32: pubKeyBech32,
                        signerType: 'nosign',
                    })];
            });
        });
    };
    WalletClient.prototype.disconnect = function () {
        clearInterval(this.broadcastQueueIntervalId);
        clearInterval(this.neoDepositsIntervalId);
    };
    WalletClient.prototype.sign = function (message) {
        var privKey = this.privKey;
        var data = privKey.sign(message);
        var signatureBase64 = Buffer.from(data.signature).toString('base64');
        return {
            pub_key: {
                type: 'tendermint/PubKeySecp256k1',
                value: this.pubKeyBase64,
            },
            signature: signatureBase64,
        };
    };
    WalletClient.prototype.initialize = function (params) {
        if (params.fees) {
            this.fees = params.fees;
        }
        if (params.accountNumber) {
            this.accountNumber = params.accountNumber;
        }
    };
    WalletClient.prototype.broadcast = function (body) {
        return fetch(this.network.REST_URL + "/txs", { method: 'POST', body: JSON.stringify(body) })
            .then(function (res) { return res.json(); }); // expecting a json response
    };
    WalletClient.prototype.getAccount = function () {
        return fetch(this.network.REST_URL + "/get_account?account=" + this.pubKeyBech32)
            .then(function (res) { return res.json(); }); // expecting a json response
    };
    WalletClient.prototype.getWalletBalance = function () {
        return fetch(this.network.REST_URL + "/get_balance?account=" + this.pubKeyBech32)
            .then(function (res) { return res.json(); }); // expecting a json response
    };
    WalletClient.prototype.getTransfers = function () {
        return fetch(this.network.REST_URL + "/get_external_transfers?account=" + this.pubKeyBech32)
            .then(function (res) { return res.json(); }); // expecting a json response
    };
    WalletClient.prototype.watchDepositAddresses = function (whitelistDenoms) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this.watchNeoDepositAddress(whitelistDenoms);
                this.watchEthDepositAddress(whitelistDenoms);
                return [2 /*return*/];
            });
        });
    };
    WalletClient.prototype.watchNeoDepositAddress = function (whitelistDenoms) {
        return __awaiter(this, void 0, void 0, function () {
            var address;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getDepositAddress(Blockchain.Neo)];
                    case 1:
                        address = _a.sent();
                        return [4 /*yield*/, this.sendNeoDeposits(address, whitelistDenoms)
                            // check every 15 seconds
                        ];
                    case 2:
                        _a.sent();
                        // check every 15 seconds
                        this.neoDepositsIntervalId = setInterval(function () {
                            _this.sendNeoDeposits(address, whitelistDenoms);
                        }, 15 * 1000);
                        return [2 /*return*/];
                }
            });
        });
    };
    WalletClient.prototype.sendNeoDeposits = function (address, whitelistDenoms) {
        return __awaiter(this, void 0, void 0, function () {
            var url, tokens, i, token, feeAmount;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getNeoRpcUrl()];
                    case 1:
                        url = _a.sent();
                        return [4 /*yield*/, this.getNeoExternalBalances(address, url, whitelistDenoms)];
                    case 2:
                        tokens = _a.sent();
                        i = 0;
                        _a.label = 3;
                    case 3:
                        if (!(i < tokens.length)) return [3 /*break*/, 6];
                        token = tokens[i];
                        if (!(token.external_balance !== undefined && token.external_balance !== '0')) return [3 /*break*/, 5];
                        feeAmount = ethers.BigNumber.from('100000000');
                        return [4 /*yield*/, this.sendNeoDeposit(token, feeAmount)];
                    case 4:
                        _a.sent();
                        _a.label = 5;
                    case 5:
                        i++;
                        return [3 /*break*/, 3];
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    WalletClient.prototype.getTargetProxyHash = function (token) {
        var prefix = getBech32Prefix(this.network, 'main');
        var address = Address.fromBech32(prefix, token.originator);
        var addressBytes = address.toBytes();
        var addressHex = stripHexPrefix(ethers.utils.hexlify(addressBytes));
        return addressHex;
    };
    WalletClient.prototype.getFeeInfo = function (denom) {
        return __awaiter(this, void 0, void 0, function () {
            var url, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = this.network.FEE_URL + '/fees?denom=' + denom;
                        return [4 /*yield*/, fetch(url).then(function (res) { return res.json(); })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result];
                }
            });
        });
    };
    WalletClient.prototype.sendNeoDeposit = function (token, feeAmountInput, _privateKey) {
        if (_privateKey === void 0) { _privateKey = null; }
        return __awaiter(this, void 0, void 0, function () {
            var privateKey, account, scriptHash, fromAssetHash, fromAddress, targetProxyHash, toAssetHash, toAddress, amount, feeAmount, feeAddress, nonce, sb, rpcUrl, apiProvider;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        privateKey = !!_privateKey ? _privateKey : this.hdWallet[Blockchain.Neo];
                        account = Neon.create.account(privateKey);
                        scriptHash = u.reverseHex(token.lock_proxy_hash);
                        fromAssetHash = token.asset_id;
                        fromAddress = u.reverseHex(account.scriptHash);
                        targetProxyHash = this.getTargetProxyHash(token);
                        toAssetHash = u.str2hexstring(token.denom);
                        toAddress = this.addressHex;
                        amount = ethers.BigNumber.from(token.external_balance);
                        feeAmount = ethers.BigNumber.from(feeAmountInput !== null && feeAmountInput !== void 0 ? feeAmountInput : '100000000');
                        feeAddress = this.network.FEE_ADDRESS;
                        nonce = Math.floor(Math.random() * 1000000);
                        if (amount.lt(feeAmount)) {
                            return [2 /*return*/, false];
                        }
                        sb = Neon.create.scriptBuilder();
                        sb.emitAppCall(scriptHash, 'lock', [
                            fromAssetHash,
                            fromAddress,
                            targetProxyHash,
                            toAssetHash,
                            toAddress,
                            amount.toNumber(),
                            feeAmount.toNumber(),
                            feeAddress,
                            nonce
                        ]);
                        return [4 /*yield*/, this.getNeoRpcUrl()];
                    case 1:
                        rpcUrl = _a.sent();
                        apiProvider = this.network.NAME === 'mainnet' ?
                            new api.neonDB.instance('https://api.switcheo.network')
                            : new api.neoCli.instance(rpcUrl);
                        return [2 /*return*/, Neon.doInvoke({
                                api: apiProvider,
                                url: rpcUrl,
                                account: account,
                                script: sb.str,
                                gas: 0,
                                fees: 0
                            })];
                }
            });
        });
    };
    WalletClient.prototype.watchEthDepositAddress = function (whitelistDenoms) {
        return __awaiter(this, void 0, void 0, function () {
            var address, dagger, transferKey;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getDepositAddress(Blockchain.Ethereum)
                        // do an initial check
                    ];
                    case 1:
                        address = _a.sent();
                        // do an initial check
                        return [4 /*yield*/, this.sendEthDeposits(address, whitelistDenoms)];
                    case 2:
                        // do an initial check
                        _a.sent();
                        dagger = new Dagger(this.network.ETH_WS_URL);
                        // watch for Ethereum transfers
                        dagger.on("latest:addr/" + address + "/tx/in", function () {
                            _this.sendEthDeposits(address, whitelistDenoms);
                        });
                        transferKey = '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef';
                        dagger.on("latest:log/+/filter/" + transferKey + "/+/" + address + "/#", function () {
                            _this.sendEthDeposits(address, whitelistDenoms);
                        });
                        return [2 /*return*/];
                }
            });
        });
    };
    WalletClient.prototype.sendEthDeposits = function (address, whitelistDenoms) {
        return __awaiter(this, void 0, void 0, function () {
            var tokens, _loop_1, i;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getEthExternalBalances(address, whitelistDenoms)];
                    case 1:
                        tokens = _a.sent();
                        _loop_1 = function (i) {
                            var token = tokens[i];
                            var balance = ethers.BigNumber.from(token.external_balance);
                            if (!balance.isZero()) {
                                // send the deposit in 30 seconds to avoid problems with block re-orgs
                                // if the deposit is sent too early, and there is a block re-org then the
                                // ethpayer service might check and see that there is no token balance and
                                // it would ignore the request
                                setTimeout(function () { return __awaiter(_this, void 0, void 0, function () {
                                    var e_1;
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0:
                                                _a.trys.push([0, 2, , 3]);
                                                return [4 /*yield*/, this.sendEthDeposit(token, address)];
                                            case 1:
                                                _a.sent();
                                                return [3 /*break*/, 3];
                                            case 2:
                                                e_1 = _a.sent();
                                                console.error('could not send deposit', e_1);
                                                return [3 /*break*/, 3];
                                            case 3: return [2 /*return*/];
                                        }
                                    });
                                }); }, 30);
                            }
                        };
                        for (i = 0; i < tokens.length; i++) {
                            _loop_1(i);
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    WalletClient.prototype.isEthContract = function (address) {
        return __awaiter(this, void 0, void 0, function () {
            var provider, code;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        provider = this.getEthProvider();
                        return [4 /*yield*/, provider.getCode(address)
                            // non-contract addresses should return 0x
                        ];
                    case 1:
                        code = _a.sent();
                        // non-contract addresses should return 0x
                        return [2 /*return*/, code != '0x'];
                }
            });
        });
    };
    WalletClient.prototype.getDepositFeeAmount = function (token, depositAddress) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var feeInfo, feeAmount, walletContractDeployed;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0: return [4 /*yield*/, this.getFeeInfo(token.denom)];
                    case 1:
                        feeInfo = _c.sent();
                        if (!((_b = (_a = feeInfo.details) === null || _a === void 0 ? void 0 : _a.deposit) === null || _b === void 0 ? void 0 : _b.fee)) {
                            throw new Error('unsupported token');
                        }
                        feeAmount = ethers.BigNumber.from(feeInfo.details.deposit.fee);
                        if (!(token.blockchain == Blockchain.Ethereum)) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.isEthContract(depositAddress)];
                    case 2:
                        walletContractDeployed = _c.sent();
                        if (!walletContractDeployed) {
                            feeAmount = feeAmount.add(ethers.BigNumber.from(feeInfo.details.createWallet.fee));
                        }
                        _c.label = 3;
                    case 3: return [2 /*return*/, feeAmount];
                }
            });
        });
    };
    WalletClient.prototype.getWithdrawalFeeAmount = function (token) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var feeInfo;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0: return [4 /*yield*/, this.getFeeInfo(token.denom)];
                    case 1:
                        feeInfo = _c.sent();
                        if (!((_b = (_a = feeInfo.details) === null || _a === void 0 ? void 0 : _a.withdrawal) === null || _b === void 0 ? void 0 : _b.fee)) {
                            throw new Error('unsupported token');
                        }
                        return [2 /*return*/, ethers.BigNumber.from(feeInfo.details.withdrawal.fee)];
                }
            });
        });
    };
    WalletClient.prototype.getMinDepositAmount = function (token, depositAddress) {
        return __awaiter(this, void 0, void 0, function () {
            var fee;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getDepositFeeAmount(token, depositAddress)];
                    case 1:
                        fee = _a.sent();
                        return [2 /*return*/, fee.mul(this.feeMultiplier)];
                }
            });
        });
    };
    WalletClient.prototype.getMinWithdrawalAmount = function (token) {
        return __awaiter(this, void 0, void 0, function () {
            var fee;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getWithdrawalFeeAmount(token)];
                    case 1:
                        fee = _a.sent();
                        return [2 /*return*/, fee.mul(this.feeMultiplier)];
                }
            });
        });
    };
    WalletClient.prototype.sendEthDeposit = function (token, depositAddress) {
        return __awaiter(this, void 0, void 0, function () {
            var feeAmount, amount, assetId, targetProxyHash, feeAddress, toAssetHash, nonce, message, messageBytes, privateKey, etherWallet, owner, signature, rsv, swthAddress, body, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getDepositFeeAmount(token, depositAddress)];
                    case 1:
                        feeAmount = _a.sent();
                        amount = ethers.BigNumber.from(token.external_balance);
                        if (amount.lt(feeAmount.mul(this.feeMultiplier))) {
                            return [2 /*return*/, 'insufficient balance'];
                        }
                        assetId = '0x' + token.asset_id;
                        targetProxyHash = '0x' + this.getTargetProxyHash(token);
                        feeAddress = '0x' + this.network.FEE_ADDRESS;
                        toAssetHash = ethers.utils.hexlify(ethers.utils.toUtf8Bytes(token.denom));
                        nonce = Math.floor(Math.random() * 1000000000) // random nonce to prevent replay attacks
                        ;
                        message = ethers.utils.solidityKeccak256(['string', 'address', 'bytes', 'bytes', 'bytes', 'uint256', 'uint256', 'uint256'], ['sendTokens', assetId, targetProxyHash, toAssetHash, feeAddress, amount, feeAmount, nonce]);
                        messageBytes = ethers.utils.arrayify(message);
                        privateKey = this.hdWallet[Blockchain.Ethereum];
                        etherWallet = new ethers.Wallet('0x' + privateKey);
                        owner = etherWallet.address;
                        return [4 /*yield*/, etherWallet.signMessage(messageBytes)];
                    case 2:
                        signature = _a.sent();
                        rsv = ethers.utils.splitSignature(signature);
                        swthAddress = ethers.utils.hexlify(this.address);
                        body = {
                            OwnerAddress: owner,
                            SwthAddress: swthAddress,
                            AssetHash: assetId,
                            TargetProxyHash: targetProxyHash,
                            ToAssetHash: toAssetHash,
                            Amount: amount.toString(),
                            FeeAmount: feeAmount.toString(),
                            FeeAddress: feeAddress,
                            Nonce: nonce.toString(),
                            V: rsv.v.toString(),
                            R: rsv.r,
                            S: rsv.s,
                        };
                        return [4 /*yield*/, fetch(this.network.ETH_PAYER_URL + '/deposit', { method: 'POST', body: JSON.stringify(body) })];
                    case 3:
                        result = _a.sent();
                        return [2 /*return*/, result];
                }
            });
        });
    };
    WalletClient.prototype.getDepositAddress = function (blockchain) {
        return __awaiter(this, void 0, void 0, function () {
            var depositAddress;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.depositAddresses[blockchain] !== undefined) {
                            return [2 /*return*/, this.depositAddresses[blockchain]];
                        }
                        depositAddress = '';
                        if (!(blockchain === Blockchain.Neo)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.getNeoDepositAddress()];
                    case 1:
                        depositAddress = _a.sent();
                        return [3 /*break*/, 5];
                    case 2:
                        if (!(blockchain === Blockchain.Ethereum)) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.getEthDepositAddress()];
                    case 3:
                        depositAddress = _a.sent();
                        return [3 /*break*/, 5];
                    case 4: return [2 /*return*/, 'unsupported blockchain'];
                    case 5:
                        this.depositAddresses[blockchain] = depositAddress;
                        return [2 /*return*/, depositAddress];
                }
            });
        });
    };
    WalletClient.prototype.getTokens = function () {
        return fetch(this.network.REST_URL + "/get_tokens")
            .then(function (res) { return res.json(); }); // expecting a json response
    };
    WalletClient.prototype.getNeoDepositAddress = function () {
        return __awaiter(this, void 0, void 0, function () {
            var privateKey, account;
            return __generator(this, function (_a) {
                privateKey = this.hdWallet[Blockchain.Neo];
                account = Neon.create.account(privateKey);
                return [2 /*return*/, account.address];
            });
        });
    };
    WalletClient.prototype.getEthDepositAddress = function () {
        return __awaiter(this, void 0, void 0, function () {
            var swthAddress, privateKey, owner, provider, contractAddress, contract, walletAddress;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        swthAddress = ethers.utils.hexlify(this.address);
                        privateKey = this.hdWallet[Blockchain.Ethereum];
                        owner = (new ethers.Wallet('0x' + privateKey)).address;
                        provider = this.getEthProvider();
                        contractAddress = this.network.ETH_LOCKPROXY;
                        contract = new ethers.Contract(contractAddress, LOCK_PROXY_ABI, provider);
                        return [4 /*yield*/, contract.getWalletAddress(owner, swthAddress, ETH_WALLET_BYTECODE)];
                    case 1:
                        walletAddress = _a.sent();
                        return [2 /*return*/, walletAddress];
                }
            });
        });
    };
    WalletClient.prototype.getEthProvider = function () {
        if (this.network.ETH_URL.length > 0) {
            return new ethers.providers.JsonRpcProvider(this.network.ETH_URL);
        }
        return ethers.getDefaultProvider(this.network.ETH_ENV);
    };
    WalletClient.prototype.getEthExternalBalances = function (address, whitelistDenoms) {
        return __awaiter(this, void 0, void 0, function () {
            var tokenList, tokens, assetIds, provider, contractAddress, contract, balances, i;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getTokens()];
                    case 1:
                        tokenList = _a.sent();
                        tokens = tokenList.filter(function (token) {
                            return token.blockchain == Blockchain.Ethereum &&
                                token.asset_id.length == 40 &&
                                ('0x' + token.lock_proxy_hash).toLowerCase() == _this.network.ETH_LOCKPROXY &&
                                (!whitelistDenoms || whitelistDenoms.includes(token.denom));
                        });
                        assetIds = tokens.map(function (token) { return '0x' + token.asset_id; });
                        provider = this.getEthProvider();
                        contractAddress = this.network.ETH_BALANCE_READER;
                        contract = new ethers.Contract(contractAddress, BALANCE_READER_ABI, provider);
                        return [4 /*yield*/, contract.getBalances(address, assetIds)];
                    case 2:
                        balances = _a.sent();
                        for (i = 0; i < tokens.length; i++) {
                            tokens[i].external_balance = balances[i].toString();
                        }
                        return [2 /*return*/, tokens];
                }
            });
        });
    };
    WalletClient.prototype.getNeoRpcUrl = function () {
        return __awaiter(this, void 0, void 0, function () {
            var response, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, fetch("https://api.switcheo.network/v2/network/best_node")
                                .then(function (res) { return res.json(); })];
                    case 1:
                        response = _b.sent();
                        return [2 /*return*/, response.node];
                    case 2:
                        _a = _b.sent();
                        return [2 /*return*/, this.getRandomNeoRpcUrl()];
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    WalletClient.prototype.getRandomNeoRpcUrl = function () {
        var urls = this.network.NEO_URLS;
        var index = Math.floor(Math.random() * urls.length);
        return urls[index];
    };
    WalletClient.prototype.parseHexNum = function (hex, exp) {
        if (exp === void 0) { exp = 0; }
        if (!hex || typeof (hex) !== 'string')
            return '0';
        var res = hex.length % 2 !== 0 ? "0" + hex : hex;
        return new BigNumber(res ? neonUtils.reverseHex(res) : '00', 16).shiftedBy(-exp).toString();
    };
    WalletClient.prototype.getNeoExternalBalances = function (address, url, whitelistDenoms) {
        return __awaiter(this, void 0, void 0, function () {
            var tokenList, account, tokens, client, promises, result, i, token;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getTokens()];
                    case 1:
                        tokenList = _a.sent();
                        account = new neonWallet.Account(address);
                        tokens = tokenList.filter(function (token) {
                            return token.blockchain == Blockchain.Neo &&
                                token.asset_id.length == 40 &&
                                token.lock_proxy_hash.length == 40;
                        });
                        client = new neonRPC.RPCClient(url, '2.5.2') // TODO: should we change the RPC version??
                        ;
                        promises = chunk(tokens, 75).map(function (partition) { return __awaiter(_this, void 0, void 0, function () {
                            var acc, _i, partition_1, token, sb, response, err_1;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        acc = {};
                                        _i = 0, partition_1 = partition;
                                        _a.label = 1;
                                    case 1:
                                        if (!(_i < partition_1.length)) return [3 /*break*/, 6];
                                        token = partition_1[_i];
                                        if (whitelistDenoms && !whitelistDenoms.includes(token.denom))
                                            return [3 /*break*/, 5];
                                        sb = new neonScript.ScriptBuilder();
                                        sb.emitAppCall(Neon.u.reverseHex(token.asset_id), 'balanceOf', [neonUtils.reverseHex(account.scriptHash)]);
                                        _a.label = 2;
                                    case 2:
                                        _a.trys.push([2, 4, , 5]);
                                        return [4 /*yield*/, client.invokeScript(sb.str)];
                                    case 3:
                                        response = _a.sent();
                                        acc[token.denom.toUpperCase()] = response.stack[0].type === 'Integer' // Happens on polychain devnet
                                            ? response.stack[0].value
                                            : this.parseHexNum(response.stack[0].value);
                                        return [3 /*break*/, 5];
                                    case 4:
                                        err_1 = _a.sent();
                                        console.error('Could not retrieve external balance for ', token.denom);
                                        console.error(err_1);
                                        return [3 /*break*/, 5];
                                    case 5:
                                        _i++;
                                        return [3 /*break*/, 1];
                                    case 6: return [2 /*return*/, acc];
                                }
                            });
                        }); });
                        return [4 /*yield*/, Promise.all(promises).then(function (results) {
                                return results.reduce(function (acc, res) { return (__assign(__assign({}, acc), res)); }, {});
                            })];
                    case 2:
                        result = _a.sent();
                        for (i = 0; i < tokens.length; i++) {
                            token = tokens[i];
                            tokens[i].external_balance = result[token.denom.toUpperCase()];
                        }
                        return [2 /*return*/, tokens];
                }
            });
        });
    };
    WalletClient.prototype.signMessage = function (msgs, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var sequence, result, result, memo, feeAmount, stdSignMsg, signatureBase64, sigData;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        sequence = options.sequence;
                        if (!(sequence === undefined || sequence === null)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.getAccount()];
                    case 1:
                        result = (_a.sent()).result;
                        sequence = result.value.sequence;
                        _a.label = 2;
                    case 2:
                        if (!(this.accountNumber === '0' || !this.accountNumber)) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.getAccount()];
                    case 3:
                        result = (_a.sent()).result;
                        this.accountNumber = result.value.account_number.toString();
                        if (this.accountNumber === '0') {
                            throw new Error('Account number still 0 after refetching. This suggests your account is not initialized with funds');
                        }
                        _a.label = 4;
                    case 4:
                        memo = options.memo || '';
                        feeAmount = (new BigNumber(msgs.length)).shiftedBy(8).toString();
                        if (options && options.fee) {
                            feeAmount = options.fee.amount[0].amount;
                        }
                        stdSignMsg = new StdSignDoc({
                            accountNumber: this.accountNumber,
                            chainId: this.network.CHAIN_ID,
                            fee: new Fee([{
                                    denom: 'swth',
                                    amount: feeAmount,
                                }], this.gas),
                            memo: memo,
                            msgs: msgs,
                            sequence: sequence.toString(),
                        });
                        if (!(this.signerType === 'ledger')) return [3 /*break*/, 8];
                        if (!this.ledger) {
                            throw new Error('Ledger connection not found, please refresh the page and try again');
                        }
                        this.onRequestSign && this.onRequestSign(stdSignMsg);
                        signatureBase64 = void 0;
                        _a.label = 5;
                    case 5:
                        _a.trys.push([5, , 7, 8]);
                        return [4 /*yield*/, this.ledger.sign(sortAndStringifyJSON(stdSignMsg))];
                    case 6:
                        sigData = _a.sent();
                        signatureBase64 = Buffer.from(sigData).toString('base64');
                        return [2 /*return*/, {
                                pub_key: {
                                    type: 'tendermint/PubKeySecp256k1',
                                    value: this.pubKeyBase64,
                                },
                                signature: signatureBase64,
                            }];
                    case 7:
                        this.onSignComplete && this.onSignComplete(signatureBase64 && signatureBase64.toString());
                        return [7 /*endfinally*/];
                    case 8: return [2 /*return*/, this.sign(marshalJSON(stdSignMsg))];
                }
            });
        });
    };
    WalletClient.prototype.signAndBroadcast = function (msgs, types, options) {
        return __awaiter(this, void 0, void 0, function () {
            var concreteMsgs, signature, broadcastTxBody;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.useSequenceCounter === true)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.seqSignAndBroadcast(msgs, types, options)];
                    case 1: return [2 /*return*/, _a.sent()];
                    case 2:
                        concreteMsgs = this.constructConcreteMsgs(msgs, types);
                        return [4 /*yield*/, this.signMessage(concreteMsgs, options)];
                    case 3:
                        signature = _a.sent();
                        broadcastTxBody = new Transaction(concreteMsgs, [signature], options);
                        return [2 /*return*/, this.broadcast(broadcastTxBody)];
                }
            });
        });
    };
    WalletClient.prototype.seqSignAndBroadcast = function (msgs, types, options) {
        return __awaiter(this, void 0, void 0, function () {
            var concreteMsgs, id, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        concreteMsgs = this.constructConcreteMsgs(msgs, types);
                        id = Math.random().toString(36).substr(2, 9);
                        this.broadcastQueue.push({ id: id, concreteMsgs: concreteMsgs, options: options });
                        _a.label = 1;
                    case 1:
                        if (!true) return [3 /*break*/, 3];
                        // sleep for broadcastQueueIntervalTime ms
                        return [4 /*yield*/, new Promise(function (resolve) { return setTimeout(resolve, 100); })];
                    case 2:
                        // sleep for broadcastQueueIntervalTime ms
                        _a.sent();
                        result = this.broadcastResults[id];
                        if (result !== undefined) {
                            if (result instanceof Error)
                                throw result;
                            delete this.broadcastResults[id];
                            return [2 /*return*/, result];
                        }
                        return [3 /*break*/, 1];
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    WalletClient.prototype.processBroadcastQueue = function () {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        return __awaiter(this, void 0, void 0, function () {
            var result, ids, allConcreteMsgs, memo, fee, ONE_SWTH_FEE, _j, id, concreteMsgs, options_1, incomingFee, newFeeAmount, currSequence, options, response, rawLogs, error, signature, broadcastTxBody, e_2, i, id, responseCopy, isInvalidSequence;
            return __generator(this, function (_k) {
                switch (_k.label) {
                    case 0:
                        if (this.broadcastQueue.length === 0) {
                            return [2 /*return*/];
                        }
                        if (this.isBroadcastQueuePaused === true) {
                            return [2 /*return*/];
                        }
                        this.isBroadcastQueuePaused = true;
                        if (!(this.sequenceCounter === undefined)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.getAccount()];
                    case 1:
                        result = (_k.sent()).result;
                        this.sequenceCounter = result.value.sequence;
                        _k.label = 2;
                    case 2:
                        ids = [];
                        allConcreteMsgs = [];
                        ONE_SWTH_FEE = "100000000";
                        while (true) {
                            if (this.broadcastQueue.length === 0) {
                                break;
                            }
                            if (allConcreteMsgs.length + this.broadcastQueue[0].concreteMsgs.length > 100) {
                                break;
                            }
                            _j = this.broadcastQueue[0], id = _j.id, concreteMsgs = _j.concreteMsgs, options_1 = _j.options;
                            if (options_1 && options_1.fee) {
                                if ((_b = (_a = fee === null || fee === void 0 ? void 0 : fee.amount) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.amount) {
                                    incomingFee = new BigNumber((_e = (_d = (_c = options_1.fee.amount) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.amount) !== null && _e !== void 0 ? _e : ONE_SWTH_FEE);
                                    newFeeAmount = new BigNumber((_h = (_g = (_f = fee.amount) === null || _f === void 0 ? void 0 : _f[0]) === null || _g === void 0 ? void 0 : _g.amount) !== null && _h !== void 0 ? _h : ONE_SWTH_FEE).plus(incomingFee);
                                    fee.amount[0].amount = newFeeAmount.toString(10);
                                }
                                else {
                                    fee = options_1.fee;
                                }
                            }
                            // there can only be one memo per txn
                            // so if there is a memo, we want to put it in a queue by itself
                            if (options_1 && options_1.memo !== undefined && options_1.memo.length > 0) {
                                // the queue is not empty, so we just break for now
                                if (ids.length !== 0) {
                                    break;
                                }
                                // the queue is empty, so we assign the memo
                                memo = options_1.memo;
                            }
                            ids.push(id);
                            allConcreteMsgs = allConcreteMsgs.concat(concreteMsgs);
                            // pop the first element, since we have enqueued it
                            this.broadcastQueue.shift();
                            // since there is a memo here, we just break to ensure that
                            // there will only be one msg in this batch
                            if (memo !== undefined) {
                                break;
                            }
                        }
                        currSequence = this.sequenceCounter.toString();
                        options = { sequence: currSequence, memo: memo, mode: 'block', fee: fee };
                        _k.label = 3;
                    case 3:
                        _k.trys.push([3, 6, , 7]);
                        return [4 /*yield*/, this.signMessage(allConcreteMsgs, options)];
                    case 4:
                        signature = _k.sent();
                        broadcastTxBody = new Transaction(allConcreteMsgs, [signature], options);
                        return [4 /*yield*/, this.broadcast(broadcastTxBody)];
                    case 5:
                        response = _k.sent();
                        response.sequence = currSequence;
                        try {
                            rawLogs = JSON.parse(response.raw_log);
                        }
                        catch (e) {
                            // ignore parsing error
                        }
                        // increment sequence counter only if tx not added to chain
                        if (response.height && response.height !== '0') {
                            this.sequenceCounter++;
                        }
                        return [3 /*break*/, 7];
                    case 6:
                        e_2 = _k.sent();
                        error = e_2;
                        return [3 /*break*/, 7];
                    case 7:
                        for (i = 0; i < ids.length; i++) {
                            id = ids[i];
                            if (error) {
                                // store error as result as workaround
                                // need to develop better error handling structure
                                this.broadcastResults[id] = error;
                                continue;
                            }
                            responseCopy = JSON.parse(JSON.stringify(response));
                            if (response.logs !== undefined) {
                                responseCopy.logs = [response.logs[i]];
                            }
                            if (rawLogs !== undefined) {
                                responseCopy.raw_log = JSON.stringify([rawLogs[i]]);
                            }
                            this.broadcastResults[id] = responseCopy;
                        }
                        if (response) {
                            isInvalidSequence = response.raw_log === 'unauthorized: signature verification failed; verify correct account sequence and chain-id';
                            if (isInvalidSequence) {
                                // reset sequenceCounter
                                this.sequenceCounter = undefined;
                            }
                        }
                        this.isBroadcastQueuePaused = false;
                        return [2 /*return*/];
                }
            });
        });
    };
    WalletClient.prototype.constructConcreteMsgs = function (msgs, types) {
        if (msgs.length != types.length)
            throw new Error('Msg length is not equal to types length');
        if (msgs.length > 100)
            throw new Error('Cannot broadcast more than 100 messages in 1 transaction');
        var concreteMsgs = [];
        // format message with concrete codec type
        for (var i = 0; i < msgs.length; i++) {
            concreteMsgs[i] = {
                type: types[i],
                value: msgs[i],
            };
        }
        return concreteMsgs;
    };
    return WalletClient;
}());
export { WalletClient };
export function getPrivKeyFromMnemonic(mnemonic) {
    var path = getPath();
    var seed = bip39.mnemonicToSeedSync(mnemonic, '');
    var masterKey = bip32.fromSeed(seed);
    var hd = masterKey.derivePath(path);
    var privateKey = hd.privateKey;
    if (!privateKey) {
        throw new Error('null hd key');
    }
    return privateKey.toString('hex');
}
export function newAccount(net) {
    var network = getNetwork(net);
    var mnemonic = bip39.generateMnemonic();
    var privateKey = getPrivKeyFromMnemonic(mnemonic);
    var pubKeyBech32 = new PrivKeySecp256k1(Buffer.from(privateKey, 'hex')).toPubKey().toAddress().toBech32(getBech32Prefix(network));
    return {
        mnemonic: mnemonic,
        privateKey: privateKey,
        pubKeyBech32: pubKeyBech32,
    };
}
export function accountFromMnemonic(mnemonic, net) {
    var network = getNetwork(net);
    var privateKey = getPrivKeyFromMnemonic(mnemonic);
    var pubKeyBech32 = new PrivKeySecp256k1(Buffer.from(privateKey, 'hex')).toPubKey().toAddress().toBech32(getBech32Prefix(network));
    return {
        mnemonic: mnemonic,
        privateKey: privateKey,
        pubKeyBech32: pubKeyBech32,
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2FsbGV0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2xpYi9jbGllbnRzL3dhbGxldC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLE9BQU8sS0FBSyxLQUFLLE1BQU0sT0FBTyxDQUFBO0FBQzlCLE9BQU8sS0FBSyxLQUFLLE1BQU0sT0FBTyxDQUFBO0FBQzlCLE9BQU8sS0FBSyxNQUFNLFlBQVksQ0FBQTtBQUM5QixPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sY0FBYyxDQUFBO0FBQ3hDLE9BQU8sTUFBTSxNQUFNLDBCQUEwQixDQUFBO0FBQzdDLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxRQUFRLENBQUE7QUFDL0IsT0FBTyxFQUFFLE1BQU0sRUFBRSxlQUFlLEVBQUUsVUFBVSxFQUFXLE1BQU0sV0FBVyxDQUFBO0FBQ3hFLE9BQU8sRUFBRSxHQUFHLEVBQUUsVUFBVSxFQUFFLFdBQVcsRUFBRSxNQUFNLGVBQWUsQ0FBQTtBQUM1RCxPQUFPLEVBQUUsV0FBVyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sa0JBQWtCLENBQUE7QUFDcEUsT0FBTyxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsZUFBZSxFQUFFLE1BQU0saUJBQWlCLENBQUE7QUFFckYsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLG1CQUFtQixDQUFBO0FBQzVDLE9BQU8sa0JBQWtCLE1BQU0sZ0NBQWdDLENBQUE7QUFDL0QsT0FBTyxjQUFjLE1BQU0sNEJBQTRCLENBQUE7QUFDdkQsT0FBTyxFQUFFLFVBQVUsRUFBRSxtQkFBbUIsRUFBRSxNQUFNLGNBQWMsQ0FBQTtBQUM5RCxPQUFPLElBQUksRUFBRSxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQTtBQUNsRCxPQUFPLGNBQWMsTUFBTSxrQkFBa0IsQ0FBQTtB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