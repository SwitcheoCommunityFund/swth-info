var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var _a;
import * as ethSignUtils from 'eth-sig-util';
import RegistryContract from './registry_contract';
import { ethers } from 'ethers';
import { Network } from '../../types';
import { NETWORK } from '../../config';
var CONTRACT_HASH = (_a = {},
    // use same ropsten contract for all non-mainnet uses
    _a[Network.TestNet] = '0x23629C94F4e8b719094f5D1Ae1c1AA8d6d687966',
    _a[Network.DevNet] = '0x23629C94F4e8b719094f5D1Ae1c1AA8d6d687966',
    _a[Network.LocalHost] = '0x23629C94F4e8b719094f5D1Ae1c1AA8d6d687966',
    _a[Network.MainNet] = '0xf4552877A40c1527D38970F170993660084D4541',
    _a);
var ETH_CHAIN_NAMES = {
    1: 'MainNet',
    3: 'Ropsten',
};
var ENCRYPTION_VERSION = 'x25519-xsalsa20-poly1305';
var MNEMONIC_MATCH_REGEX = /-----BEGIN MNEMONIC PHRASE-----([a-z\s]*)-----END MNEMONIC PHRASE-----/mi;
var MNEMONIC_MATCH_REGEX_LEGACY = /^[a-z\s]*$/i;
var getRequiredEthChain = function (network) {
    if (network === Network.MainNet) {
        return 1;
    }
    return 3;
};
var getEncryptMessage = function (input) {
    return ("\n  !!! Attention !!! Please make sure you are connecting to https://app.dem.exchange, do not confirm decrypt if you're connecting to untrusted sites.\n  -----BEGIN MNEMONIC PHRASE-----\n  " + input + "\n  -----END MNEMONIC PHRASE-----\n  ").trim().replaceAll(/^\s+/gm, '');
};
/**
 * TODO: Add docs
 */
var MetaMask = /** @class */ (function () {
    function MetaMask(network) {
        this.network = network;
        this.metamaskAPI = null;
        this.provider = null;
        var providerUrl = NETWORK[network].ETH_URL;
        if (providerUrl) {
            this.provider = new ethers.providers.JsonRpcProvider(providerUrl);
        }
    }
    MetaMask.prototype.checkProvider = function () {
        if (!this.provider) {
            throw new Error("MetaMask login not supported for this network " + this.network);
        }
        return this.provider;
    };
    MetaMask.prototype.getConnectedAPI = function () {
        return __awaiter(this, void 0, void 0, function () {
            var metamaskAPI;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.metamaskAPI && this.metamaskAPI.isConnected()) {
                            return [2 /*return*/, this.metamaskAPI];
                        }
                        metamaskAPI = window.ethereum;
                        if (metamaskAPI === undefined) {
                            throw new Error('MetaMask not connected, please check that your extension is enabled');
                        }
                        if (metamaskAPI.isConnected()) {
                            return [2 /*return*/, metamaskAPI];
                        }
                        return [4 /*yield*/, metamaskAPI.request({ method: 'eth_requestAccounts' })];
                    case 1:
                        _a.sent();
                        this.metamaskAPI = metamaskAPI;
                        return [2 /*return*/, this.metamaskAPI];
                }
            });
        });
    };
    MetaMask.prototype.connect = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.getConnectedAPI()];
            });
        });
    };
    MetaMask.prototype.defaultAccount = function () {
        return __awaiter(this, void 0, void 0, function () {
            var metamaskAPI, defaultAccount;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getConnectedAPI()];
                    case 1:
                        metamaskAPI = _a.sent();
                        return [4 /*yield*/, metamaskAPI.request({ method: 'eth_requestAccounts' })];
                    case 2:
                        defaultAccount = (_a.sent())[0];
                        if (!defaultAccount) {
                            throw new Error('No default account on MetaMask, please create one first');
                        }
                        return [2 /*return*/, defaultAccount];
                }
            });
        });
    };
    MetaMask.prototype.getStoredMnemonicCipher = function (account) {
        return __awaiter(this, void 0, void 0, function () {
            var contractHash, provider, contract, cipherTextHex;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        contractHash = this.getContractHash();
                        provider = this.checkProvider();
                        contract = new ethers.Contract(contractHash, RegistryContract.abi, provider);
                        return [4 /*yield*/, contract.map(account)];
                    case 1:
                        cipherTextHex = _a.sent();
                        if (!(cipherTextHex === null || cipherTextHex === void 0 ? void 0 : cipherTextHex.length) || cipherTextHex === '0x') {
                            // value would be '0x' if not initialized
                            return [2 /*return*/, undefined];
                        }
                        return [2 /*return*/, cipherTextHex];
                }
            });
        });
    };
    MetaMask.prototype.encryptMnemonic = function (mnemonic) {
        return __awaiter(this, void 0, void 0, function () {
            var metamaskAPI, defaultAccount, publicKey, messageToEncrypt, cipher, version, nonce, ephemPublicKey, ciphertext, encryptedMnemonic;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getConnectedAPI()];
                    case 1:
                        metamaskAPI = _a.sent();
                        return [4 /*yield*/, this.defaultAccount()];
                    case 2:
                        defaultAccount = _a.sent();
                        return [4 /*yield*/, metamaskAPI.request({
                                method: 'eth_getEncryptionPublicKey',
                                params: [defaultAccount],
                            })];
                    case 3:
                        publicKey = _a.sent();
                        messageToEncrypt = getEncryptMessage(mnemonic);
                        cipher = ethSignUtils.encrypt(publicKey, {
                            data: messageToEncrypt,
                        }, ENCRYPTION_VERSION);
                        version = cipher.version, nonce = cipher.nonce, ephemPublicKey = cipher.ephemPublicKey, ciphertext = cipher.ciphertext;
                        encryptedMnemonic = ethers.utils.toUtf8Bytes([
                            version,
                            nonce,
                            ephemPublicKey,
                            ciphertext,
                        ].join('.'));
                        return [2 /*return*/, Buffer.from(encryptedMnemonic).toString('hex')];
                }
            });
        });
    };
    MetaMask.prototype.storeMnemonic = function (encryptedMnemonic) {
        return __awaiter(this, void 0, void 0, function () {
            var metamaskAPI, defaultAccount, storedMnemonicCipher, contractHash, provider, contract, dataBytes, unsignedTx, txHash;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getConnectedAPI()];
                    case 1:
                        metamaskAPI = _a.sent();
                        return [4 /*yield*/, this.defaultAccount()];
                    case 2:
                        defaultAccount = _a.sent();
                        return [4 /*yield*/, this.getStoredMnemonicCipher(defaultAccount)];
                    case 3:
                        storedMnemonicCipher = _a.sent();
                        if (storedMnemonicCipher) {
                            throw new Error('Cannot store key on registry - key already exists for ETH account');
                        }
                        contractHash = this.getContractHash();
                        provider = this.checkProvider();
                        contract = new ethers.Contract(contractHash, RegistryContract.abi, provider);
                        dataBytes = Buffer.from(encryptedMnemonic, 'hex');
                        return [4 /*yield*/, contract.populateTransaction.Store(dataBytes)];
                    case 4:
                        unsignedTx = _a.sent();
                        return [4 /*yield*/, metamaskAPI.request({
                                method: 'eth_sendTransaction',
                                params: [__assign(__assign({}, unsignedTx), { from: defaultAccount })],
                            })];
                    case 5:
                        txHash = _a.sent();
                        return [2 /*return*/, txHash];
                }
            });
        });
    };
    MetaMask.prototype.login = function () {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var metamaskAPI, defaultAccount, cipherTextHex, chainIdHex, chainId, requiredChainId, requiredNetworkName, cipherText, _c, version, nonce, ephemPublicKey, ciphertext, cipher, decryptedCipherText, match;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0: return [4 /*yield*/, this.getConnectedAPI()];
                    case 1:
                        metamaskAPI = _d.sent();
                        return [4 /*yield*/, this.defaultAccount()];
                    case 2:
                        defaultAccount = _d.sent();
                        return [4 /*yield*/, this.getStoredMnemonicCipher(defaultAccount)];
                    case 3:
                        cipherTextHex = _d.sent();
                        return [4 /*yield*/, metamaskAPI.request({ method: 'eth_chainId' })];
                    case 4:
                        chainIdHex = _d.sent();
                        chainId = parseInt(chainIdHex, 16);
                        requiredChainId = getRequiredEthChain(this.network);
                        if (chainId !== requiredChainId) {
                            requiredNetworkName = ETH_CHAIN_NAMES[requiredChainId] || ETH_CHAIN_NAMES[3];
                            throw new Error("MetaMask not connected to correct network, please use " + requiredNetworkName);
                        }
                        if (!cipherTextHex || !cipherTextHex.length) {
                            return [2 /*return*/, null];
                        }
                        cipherText = ethers.utils.toUtf8String(cipherTextHex);
                        _c = cipherText.split('.'), version = _c[0], nonce = _c[1], ephemPublicKey = _c[2], ciphertext = _c[3];
                        cipher = {
                            version: version,
                            nonce: nonce,
                            ephemPublicKey: ephemPublicKey,
                            ciphertext: ciphertext,
                        };
                        return [4 /*yield*/, metamaskAPI.request({
                                method: 'eth_decrypt',
                                params: [JSON.stringify(cipher), defaultAccount],
                            })];
                    case 5:
                        decryptedCipherText = (_a = (_d.sent())) === null || _a === void 0 ? void 0 : _a.trim();
                        // legacy encrypted mnemonic doesnt include warning message.
                        if (decryptedCipherText.match(MNEMONIC_MATCH_REGEX_LEGACY)) {
                            return [2 /*return*/, decryptedCipherText];
                        }
                        match = decryptedCipherText.match(MNEMONIC_MATCH_REGEX);
                        // invalid cipher
                        if (!match) {
                            console.error('invalid account info retrieved from contract');
                            console.error(decryptedCipherText);
                            throw new Error('Retrieved invalid account on blockchain, please check console for more information.');
                        }
                        return [2 /*return*/, (_b = match[1]) === null || _b === void 0 ? void 0 : _b.trim()];
                }
            });
        });
    };
    MetaMask.prototype.getContractHash = function () {
        var contractHash = CONTRACT_HASH[this.network];
        if (!contractHash) {
            throw new Error("MetaMask login is not supported on " + this.network);
        }
        return contractHash;
    };
    return MetaMask;
}());
export { MetaMask };
export default MetaMask;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWV0YU1hc2suanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvbGliL3Byb3ZpZGVycy9tZXRhbWFzay9NZXRhTWFzay50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxPQUFPLEtBQUssWUFBWSxNQUFNLGNBQWMsQ0FBQTtBQUM1QyxPQUFPLGdCQUFnQixNQUFNLHFCQUFxQixDQUFBO0FBQ2xELE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxRQUFRLENBQUE7QUFDL0IsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLGFBQWEsQ0FBQTtBQUNyQyxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sY0FBYyxDQUFBO0FBRXRDLElBQU0sYUFBYTtJQUNqQixxREFBcUQ7SUFDckQsR0FBQyxPQUFPLENBQUMsT0FBTyxJQUFHLDRDQUE0QztJQUMvRCxHQUFDLE9BQU8sQ0FBQyxNQUFNLElBQUcsNENBQTRDO0lBQzlELEdBQUMsT0FBTyxDQUFDLFNBQVMsSUFBRyw0Q0FBNEM7SUFFakUsR0FBQyxPQUFPLENBQUMsT0FBTyxJQUFHLDRDQUE0QztPQUNoRSxDQUFBO0FBRUQsSUFBTSxlQUFlLEdBQUc7SUFDdEIsQ0FBQyxFQUFFLFNBQVM7SUFDWixDQUFDLEVBQUUsU0FBUztDQUNKLENBQUE7QUFFVixJQUFNLGtCQUFrQixHQUFHLDBCQUEwQixDQUFBO0FBRXJELElBQU0sb0JBQW9CLEdBQUcsMEVBQTBFLENBQUE7QUFDdkcsSUFBTSwyQkFBMkIsR0FBRyxhQUFhLENBQUE7QUFFakQsSUFBTSxtQkFBbUIsR0FBRyxVQUFDLE9BQWdCO0lBQzNDLElBQUksT0FBTyxLQUFLLE9BQU8sQ0FBQyxPQUFPLEVBQUU7UUFDL0IsT0FBTyxDQUFDLENBQUE7S0FDVDtJQUVELE9BQU8sQ0FBQyxDQUFBO0FBQ1YsQ0FBQyxDQUFBO0FBRUQsSUFBTSxpQkFBaUIs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