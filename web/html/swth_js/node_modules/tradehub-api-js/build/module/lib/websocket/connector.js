var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import NodeWebSocket from 'ws';
import { generateChannelId, parseChannelId } from './channel';
import * as WSConnectorTypes from './types';
import { logger } from '../utils';
// delay between pings.
// see WSConnector.intervalHeartbeat
var DEFAULT_INTERVAL_HEARTBEAT = 3000;
// 2x DEFAULT_INTERVAL_HEARTBEAT to allow for missing
// one heartbeat without triggering disconnect.
// see WSConnector.timeoutHeartbeat
var DEFAULT_TIMEOUT_HEARTBEAT = 6100;
// see WSConnector.timeoutConnect
var DEFAULT_TIMEOUT_CONNECT = 2000;
export var WSChannel = WSConnectorTypes.WSChannel;
export { WSConnectorTypes };
/**
 * WSConnector is a wrapper class to manage websocket connections with the server. It makes use of
 * WebSocket instances to connect to the server.
 *
 * Provides a synchronised way of executing requests on websocket @see {WSConnector.request}.
 *
 * Multiple subscriptions to the same channel is not supported at the moment, but would be trival
 * to implement.
 *
 * @example
 * (async () => {
 *   const wsConnector = new WSConnector({
 *     endpoint: WS_ENDPOINT,
 *   });
 *
 *   // run connect before executing any request/subscription
 *   await wsConnector.connect();
 *
 *   // request for data
 *   const result: WSResult<RecentTradesBody> = await wsConnector.request<RecentTradesBody>("get_recent_trades", {
 *      market: "swth_eth",
 *   });
 *
 *   // subscribe to new channel
 *   await wsConnector.subscribe({ channel: WSChannel.market_stats }, (result: WSResult<MarketStats>) => {
 *     console.log("received market stats", result);
 *   });
 *
 *   // unsubscribe
 *   await wsConnector.unsubscribe({ channel: WSChannel.market_stats });
 *
 *   // clean up
 *   await wsConnector.disconnect();
 * })();
 */
var WSConnector = /** @class */ (function () {
    /**
     * Initialises an instance of WSConnector with the specified options
     * @param {WSConnectorOptions} options - options to configure the WSConnector instance
     */
    function WSConnector(options) {
        // websocket instance
        this.websocket = null;
        // used to tracking websocket messages, increment by 1 every request
        this.requestIdCounter = 0;
        // true if connection initiated, even if connection is not established
        // will cause reconnect attempts if true.
        this.shouldConnect = false;
        // true only if connection is established and ready to use
        this.connected = false;
        // promise abstraction handler for WSConnector.connect
        this.connectPromiseHandler = null;
        // promise abstraction handlers store for WSConnector.request
        this.requestHandlers = {};
        // channel subscription handlers
        this.channelHandlers = {};
        // used for track ws message sequence, for some cases a out of sequence
        // message is invalid and request have to be resent.
        this.sequenceNumberCache = {};
        var endpoint = options.endpoint, _a = options.debugMode, debugMode = _a === void 0 ? false : _a, _b = options.timeoutConnect, timeoutConnect = _b === void 0 ? DEFAULT_TIMEOUT_CONNECT : _b, _c = options.intervalHeartbeat, intervalHeartbeat = _c === void 0 ? DEFAULT_INTERVAL_HEARTBEAT : _c, _d = options.timeoutHeartbeat, timeoutHeartbeat = _d === void 0 ? DEFAULT_TIMEOUT_HEARTBEAT : _d, _e = options.disableHeartbeat, disableHeartbeat = _e === void 0 ? false : _e, onStatusChange = options.onStatusChange;
        this.endpoint = endpoint;
        this.debugMode = debugMode;
        this.timeoutConnect = timeoutConnect;
        this.intervalHeartbeat = intervalHeartbeat;
        this.timeoutHeartbeat = timeoutHeartbeat;
        this.disableHeartbeat = disableHeartbeat;
        this.statusChangeListener = onStatusChange;
    }
    /**
     * Starts a connection to the server via a WebSocket instance
     * rejects the promise if connection cannot be established within WSConnector.timeoutConnect
     * milliseconds.
     *
     * @see WSConnector documentation for usage example
     */
    WSConnector.prototype.connect = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                if (this.shouldConnect) {
                    // resolve promise immediately if already connecting
                    return [2 /*return*/, Promise.resolve()];
                }
                this.shouldConnect = true;
                this.connectWebSocket();
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        _this.connectPromiseHandler = { resolve: resolve, reject: reject };
                    })];
            });
        });
    };
    /**
     * Disconnects the WebSocket connection with endpoint, releases resources and reverse states.
     * It is safe to call WSConnector.connect() again once WSConnector.disconnect() is called.
     *
     * @see WSConnector documentation for usage example
     */
    WSConnector.prototype.disconnect = function () {
        this.shouldConnect = false;
        this.disconnectWebsocket();
    };
    /**
     * Subscribes to the channels specified with the websocket. Sends a subscription data frame with
     * channel ID to WebSocket server.
     * @param {WSConnectorTypes.WsSubscriptionParams | WSConnectorTypes.WsSubscriptionParams[]} params a list of parameters specifying the channels to connect to
     * @param {WSSubscriber} handler an event handler that subscribes to the websocket channels
     *
     * @see WSConnector documentation for usage example
     */
    WSConnector.prototype.subscribe = function (params, handler) {
        var channels = [];
        if (!Array.isArray(params)) {
            params = [params]; // eslint-disable-line no-param-reassign
        }
        for (var _i = 0, _a = params; _i < _a.length; _i++) {
            var param = _a[_i];
            var channelId = generateChannelId(param);
            var shouldSubscribe = this.channelHandlers[channelId] === undefined;
            this.channelHandlers[channelId] = handler;
            if (shouldSubscribe) {
                channels.push(channelId);
            }
        }
        this.send('subscribe', { channels: channels });
    };
    /**
     * Unsubscribes to the websocket channels indicated in the params, by broadcasting an unsubscribe
     * message to these channels.
     * @param {WSConnectorTypes.WsSubscriptionParams | WSConnectorTypes.WsSubscriptionParams[]} params - channel(s) to unsubcribe to
     *
     * @see WSConnector documentation for usage example
     */
    WSConnector.prototype.unsubscribe = function (params) {
        if (!Array.isArray(params)) {
            params = [params]; // eslint-disable-line no-param-reassign
        }
        var channelIds = [];
        for (var _i = 0, params_1 = params; _i < params_1.length; _i++) {
            var param = params_1[_i];
            var channelId = generateChannelId(param);
            delete this.channelHandlers[channelId];
        }
        this.send('unsubscribe', {
            channels: channelIds,
        });
    };
    /**
     * Sends a message to the websocket channels.
     * @param {string} method - the type of message to send to the websocket channels. Available
     * options: subscribe, unsubscribe, get_recent_trades, get_candlesticks, get_open_orders,
     * get_account_trades, get_market_stats, get_leverages, get_open_positions, get_closed_positions
     * @param {any} params - An object containing parameters based on the specified method
     */
    WSConnector.prototype.send = function (method, params) {
        this.sendMessage(JSON.stringify({
            id: "g" + ++this.requestIdCounter,
            method: method,
            params: params,
        }));
    };
    /**
     * Requests data from the server endpoint
     * @param {string} method - the type of message to send to the websocket channels. Available
     * options: subscribe, unsubscribe, get_recent_trades, get_candlesticks, get_open_orders,
     * get_account_trades, get_market_stats, get_leverages, get_open_positions, get_closed_positions
     * @param {any} params - parameters based on the specified method
     *
     * @returns {Promise<WSResult<T>>} - a Promise resolving to the response from the endpoint
     *
     * @see WSConnector documentation for usage example
     */
    WSConnector.prototype.request = function (method, params) {
        return __awaiter(this, void 0, void 0, function () {
            var requestId;
            var _this = this;
            return __generator(this, function (_a) {
                requestId = "r" + ++this.requestIdCounter;
                this.sendMessage(JSON.stringify({
                    id: requestId,
                    method: method,
                    params: params,
                }));
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        _this.requestHandlers[requestId] = { requestId: requestId, resolve: resolve, reject: reject };
                    })];
            });
        });
    };
    /**
     * Sends a message to the web socket
     * @param {string | Buffer} data - the message sent to the web socket
     */
    WSConnector.prototype.sendMessage = function (data) {
        var socket = this.getSocket();
        this.debugLog('WSConnector.sendMessage', data);
        socket === null || socket === void 0 ? void 0 : socket.send(data);
    };
    /**
     * An event handler that is called when a connection is started with the WebSocket instance.
     * @param {Event} ev - the event that is called with
     */
    WSConnector.prototype.onOpen = function (ev) {
        var _a;
        this.debugLog('WSConnector.onOpen', ev);
        // clear timeout for killing connect attempts
        clearTimeout(this.timeoutConnect);
        this.connected = true;
        (_a = this.connectPromiseHandler) === null || _a === void 0 ? void 0 : _a.resolve();
        this.connectPromiseHandler = null;
        this.updateConnectStatus();
        this.startHeartbeat();
    };
    /**
     * An event handler that is called when a MessageEvent is emitted from the server
     * @param {MessageEvent} ev - the MessageEvent that is emitted from the server
     */
    WSConnector.prototype.onMessage = function (ev) {
        var _a;
        this.debugLog('WSConnector.onMessage', ev);
        if (ev.data === 'pong') {
            this.restartHeartbeatTimeout();
            return;
        }
        var message = this.parseWsMessage(ev);
        if (!message.requestId && message.channel) {
            var channelHandler = this.channelHandlers[message.channel];
            if (!channelHandler) {
                this.debugLog("handler not found for channel: " + message.channel);
                this.unsubscribe({ channel: message.channel });
                return;
            }
            channelHandler(message.result);
            return;
        }
        if (!((_a = message.requestId) === null || _a === void 0 ? void 0 : _a.startsWith('r'))) {
            return;
        }
        var handler = this.requestHandlers[message.requestId];
        if (!handler) {
            this.debugLog("handler not found for request: " + message.requestId);
            return;
        }
        if (message.error) {
            handler.reject(message.error);
        }
        else {
            handler.resolve(message.result);
        }
        delete this.requestHandlers[message.requestId];
    };
    /**
     * An event listener that is called when an error occurs on the WebSocket connection
     * @param {Event} ev - the error event occurring on the WebSocket connection
     */
    WSConnector.prototype.onError = function (ev) {
        this.debugLog('WSConnector.onError', ev);
        var handlers = Object.values(this.requestHandlers);
        console.error(ev);
        var error = new Error('WebSocket error occurred');
        for (var _i = 0, handlers_1 = handlers; _i < handlers_1.length; _i++) {
            var handler = handlers_1[_i];
            handler.reject(error);
            if (handler.requestId) {
                delete this.requestHandlers[handler.requestId];
            }
        }
    };
    /**
     * An event handler that is triggered when the WebSocket connection is closed.
     * @param {Event} ev - the event called with this event handler.
     */
    WSConnector.prototype.onClose = function (ev) {
        this.debugLog('WSConnector.onClose', ev);
        this.disconnectWebsocket();
    };
    /**
     * An accessor to the WebSocket instance in this WSConnector instance
     */
    WSConnector.prototype.getSocket = function () {
        if (!this.connected) {
            throw new Error('WebSocket not connected');
        }
        return this.websocket;
    };
    /**
     * Updates the connection status of the WebSocket instance
     */
    WSConnector.prototype.updateConnectStatus = function () {
        var _a;
        try {
            (_a = this.statusChangeListener) === null || _a === void 0 ? void 0 : _a.call(this, this.connected);
        }
        catch (error) {
            console.error(error);
        }
    };
    /**
     * Sends ping messages to the websocket to indicate to the server that the WebSocket connection with the server is still alive.
     */
    WSConnector.prototype.sendHeartbeat = function () {
        var _a;
        (_a = this.websocket) === null || _a === void 0 ? void 0 : _a.send('ping');
    };
    /**
     * Resets the heartbeat timeout. (timeout: after a specified amount of time, if there are no heartbeats detected from the server, the connection with the server is considered to be lost and the WebSocket connection will be closed)
     */
    WSConnector.prototype.restartHeartbeatTimeout = function () {
        clearTimeout(this.heartbeatTimeout);
        if (this.disableHeartbeat || this.timeoutHeartbeat <= 0) {
            // configured to disable heartbeat checks
            return;
        }
        this.heartbeatTimeout = setTimeout(this.onHeartbeatTimeout.bind(this), this.timeoutHeartbeat);
    };
    /**
     * Disconnects the websocket connection when there is no heartbeat detected for more than the time specified in {@link WSConnector#timeoutHeartbeat}
     */
    WSConnector.prototype.onHeartbeatTimeout = function () {
        this.debugLog('heartbeat timed out');
        console.warn('ws heartbeat missed, killing zombie connection');
        this.disconnect();
    };
    /**
     * Starts sending heartbeats to the server in regular intervals
     */
    WSConnector.prototype.startHeartbeat = function () {
        // call receive heartbeat to start timeout
        this.restartHeartbeatTimeout();
        if (this.disableHeartbeat || this.intervalHeartbeat <= 0) {
            // configured to disable heartbeat checks
            return;
        }
        this.heartbeatInterval = setInterval(this.sendHeartbeat.bind(this), this.intervalHeartbeat);
    };
    /**
     * Parses messages sent from the server via the WebSocket connection
     * @param {MessageEvent} ev - the MessageEvent emitted from the server
     * @returns {WSMessage<T>} - the parsed message
     */
    WSConnector.prototype.parseWsMessage = function (ev) {
        try {
            var _a = JSON.parse(ev.data), id = _a.id, sequenceNumber = _a.sequence_number, error = _a.error, channel = _a.channel, rest = __rest(_a, ["id", "sequence_number", "error", "channel"]);
            var outOfSequence = sequenceNumber < this.sequenceNumberCache[channel];
            if (!outOfSequence) {
                this.sequenceNumberCache[channel] = sequenceNumber;
            }
            return {
                requestId: id,
                channel: channel,
                sequenceNumber: sequenceNumber,
                error: error,
                result: {
                    requestId: id,
                    channel: channel,
                    timestamp: new Date(),
                    outOfSequence: outOfSequence,
                    data: rest,
                },
            };
        }
        catch (error) {
            console.error(error);
            throw error;
        }
    };
    /**
     * Rejects the WebSocket connection attempt when an error is encountered
     * @param {Error} error - the error causing the failure to connect with the websocket
     */
    WSConnector.prototype.rejectConnect = function (error) {
        var _a;
        clearTimeout(this.initFailureTimeout);
        (_a = this.connectPromiseHandler) === null || _a === void 0 ? void 0 : _a.reject(error);
        this.connectPromiseHandler = null;
    };
    /**
     * Disconnects the connection with the websocket
     */
    WSConnector.prototype.disconnectWebsocket = function () {
        var _a;
        try {
            (_a = this.websocket) === null || _a === void 0 ? void 0 : _a.close();
        }
        catch (e) {
            // ignore error on disconnect
        }
        finally {
            clearInterval(this.heartbeatInterval);
            clearTimeout(this.heartbeatTimeout);
            this.sequenceNumberCache = {};
            this.websocket = null;
            if (this.connected) {
                this.connected = false;
                this.updateConnectStatus();
            }
        }
    };
    /**
     * Initialises a new WebSocket instance with the specified endpoint.
     */
    WSConnector.prototype.connectWebSocket = function () {
        var _this = this;
        this.disconnect();
        try {
            if (typeof WebSocket !== 'undefined') {
                // this works on browsers js vm
                var websocket = new WebSocket(this.endpoint);
                websocket.onopen = this.onOpen.bind(this);
                websocket.onclose = this.onClose.bind(this);
                websocket.onerror = this.onError.bind(this);
                websocket.onmessage = this.onMessage.bind(this);
                this.websocket = websocket;
            }
            else {
                // and this works on nodejs vm
                var websocket = new NodeWebSocket(this.endpoint);
                websocket.on('open', this.onOpen.bind(this));
                websocket.on('close', this.onClose.bind(this));
                websocket.on('error', this.onError.bind(this));
                websocket.on('message', function (data) { return _this.onMessage({ data: data }); });
                this.websocket = websocket;
            }
            this.requestHandlers = {};
            // set timeout to kill websocket instantiation attempt
            // because error for constructor cannot be caught
            // i.e. new WebSocket(…)
            // https://stackoverflow.com/questions/22919638
            this.initFailureTimeout = setTimeout(function () {
                _this.rejectConnect(new Error('websocket connect time out'));
            }, this.timeoutConnect);
        }
        catch (error) {
            console.error(error);
            this.rejectConnect(error);
        }
    };
    /**
     * A helper message to log methods when they are called
     * WSConnector#debugMode must be set to true to turn on logging.
     * @param {any[]} args - items to be logged
     */
    WSConnector.prototype.debugLog = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (!this.debugMode)
            return;
        logger.apply(void 0, args);
    };
    WSConnector.generateChannelId = generateChannelId;
    WSConnector.parseChannelId = parseChannelId;
    return WSConnector;
}());
export { WSConnector };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29ubmVjdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2xpYi93ZWJzb2NrZXQvY29ubmVjdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsT0FBTyxhQUFhLE1BQU0sSUFBSSxDQUFBO0FBRTlCLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxjQUFjLEVBQUUsTUFBTSxXQUFXLENBQUE7QUFDN0QsT0FBTyxLQUFLLGdCQUFnQixNQUFNLFNBQVMsQ0FBQTtBQUUzQyxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sVUFBVSxDQUFBO0FBRWpDLHVCQUF1QjtBQUN2QixvQ0FBb0M7QUFDcEMsSUFBTSwwQkFBMEIsR0FBRyxJQUFJLENBQUE7QUFFdkMscURBQXFEO0FBQ3JELCtDQUErQztBQUMvQyxtQ0FBbUM7QUFDbkMsSUFBTSx5QkFBeUIsR0FBRyxJQUFJLENBQUE7QUFFdEMsaUNBQWlDO0FBQ2pDLElBQU0sdUJBQXVCLEdBQUcsSUFBSSxDQUFBO0FBRXBDLE1BQU0sQ0FBUyxJQUFBLFNBQVMsR0FBSyxnQkFBZ0IsVUFBckIsQ0FBcUI7QUFDN0MsT0FBTyxFQUFFLGdCQUFnQixFQUFFLENBQUE7QUE2RDNCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBa0NHO0FBQ0g7SUF1RUU7OztPQUdHO0lBQ0gscUJBQ0UsT0FBMkI7UUFsRDdCLHFCQUFxQjtRQUNyQixjQUFTLEdBQXFCLElBQUksQ0FBQTtRQUVsQyxvRUFBb0U7UUFDcEUscUJBQWdCLEdBQVcsQ0FBQyxDQUFBO1FBRTVCLHNFQUFzRTtRQUN0RSx5Q0FBeUM7UUFDekMsa0JBQWEsR0FBWSxLQUFLLENBQUE7UUFFOUIsMERBQTBEO1FBQzFELGNBQVMsR0FBWSxLQUFLLENBQUE7UUFLMUIsc0RBQXNEO1FBQ3RELDBCQUFxQixHQUEwQixJQUFJLENBQUE7UUFF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